{"prompt":"<p>Given a string <code>s<\/code>, return <em>the number of <strong>palindromic substrings<\/strong> in it<\/em>.<\/p>\n\n<p>A string is a <strong>palindrome<\/strong> when it reads the same backward as forward.<\/p>\n\n<p>A <strong>substring<\/strong> is a contiguous sequence of characters within the string.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> s = &quot;abc&quot;\n<strong>Output:<\/strong> 3\n<strong>Explanation:<\/strong> Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> s = &quot;aaa&quot;\n<strong>Output:<\/strong> 6\n<strong>Explanation:<\/strong> Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000<\/code><\/li>\n\t<li><code>s<\/code> consists of lowercase English letters.<\/li>\n<\/ul>\n\n\n###\n\n","completion":" Belive me guys at the end of blog, Interviewer would be like What the f**k , you are genious man \\uD83D\\uDE42!\\n\\n## Video Solution ( In Hindi Language )\\nhttps:\/\/www.youtube.com\/watch?v=J5P4OBhFKq0&ab_channel=CSIITIAN\\n\\n# Let\\'s come to the Point\\n\\nSo if we are discussing this with interviewer first thing is obviously the brute force. So let\\'s discuss what is the brute force.\\n\\n`A Brute force is a force which is applied brutally , Joking guys.` \\n\\nLet\\'s see \\nSo I need all substring which are palindrome, and I know that every substring will have one start index and one end index. So we can have two loops first is for starting index and second is for end index. And now what I can do is, I can check if that substring is palindrome or not.\\n\\nLet\\'s code it also ( Although Interviewer don\\'t want this , Because you have to ask him if he want more optimised version )\\n```Java []\\nclass Solution {\\n\\n    public boolean isPalindrome(String s, int left, int right) {\\n        while(left < right) {\\n            if(s.charAt(left++) != s.charAt(right--)) return false;\\n        } \\n        return true;\\n    }\\n    \\n    public int countSubstrings(String s) {\\n        int ans = 0;\\n        int n = s.length();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i;j<n;j++) {\\n                if(isPalindrome(s, i, j)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/0f96944f-7fc2-482f-8ed8-45739d3c7dcc_1707528994.8980653.png)\\n\\nWtf ? Our Brute Force worked.\\n\\n\\n`Interviewer:` What would be the time and space complexity here ?\\n`You:` Time Complexity would be $$O(n^3)$$. Because we have two for loops to iterate all possible substring and one loop to check if it is palindrome or not.\\nSpace Complexity would be $$O(1)$$.\\n\\n`Interviewer:` Cany you optimise it further ?\\n`You:` Sure ( MF ).\\n\\nSo Basically If I know a string is palindrome and I divide it in two parts ( if length is even ) that would have same characters.\\nand for odd length except the middle element, all other characters would be same.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/bb06e18a-a5f6-4555-b75e-770aa8f82c3b_1707526508.128146.png)\\n\\nSo If I pick a character and expand it\\'s left and right side till I have similiar elements. Those would be palindrome. But this could be even length palindrome\\'s middle or odd length palindrome\\'s middle. So we will take care of both case.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/70c03f45-5421-4a93-9fd5-9af9719f427e_1707526790.0814319.png)\\n\\nIf it is odd, expand left = (i-1) and right = (i+1)\\nIf it is even, expand left = (i) and right = (i+1)\\n\\nWe have to do this for each character to explore all substrings.\\n\\n`Interviewer` : Approach seems good to me. Let\\'s discuss Time and Space Complexity then we can proceed for the code part.\\n`You` : Sure , Here Time Complexity would be O(n^2) because for a character worst case can be to traverse all neighbours. \\nand Space Complexity would be O(1).\\n\\nNow let\\'s code it\\n```Java []\\nclass Solution {\\n    public int countSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            int even = palindromeCount(s, i, i+1);\\n            int odd = palindromeCount(s, i-1, i+1);\\n            ans += even + odd + 1;\\n        }\\n        return ans;\\n    }\\n\\n    public int palindromeCount(String s, int left, int right) {\\n        int count = 0;\\n        while(left >= 0 && right < s.length() && s.charAt(left--) == s.charAt(right++)) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countSubstrings(string s) {\\n        int n = s.length(), ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int even = palindromeCount(s, i, i + 1);\\n            int odd = palindromeCount(s, i, i);\\n            ans += even + odd;\\n        }\\n        return ans;\\n    }\\n\\n    int palindromeCount(const string& s, int left, int right) {\\n        int count = 0;\\n        while (left >= 0 && right < s.length() && s[left] == s[right]) {\\n            --left;\\n            ++right;\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def countSubstrings(self, s: str) -> int:\\n        n, ans = len(s), 0\\n        \\n        def palindromeCount(left: int, right: int) -> int:\\n            count = 0\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n                count += 1\\n            return count\\n        \\n        for i in range(n):\\n            even = palindromeCount(i, i + 1)\\n            odd = palindromeCount(i, i)\\n            ans += even + odd\\n            \\n        return ans\\n```\\n\\n\\n\\nI\\'ve another approach for DP lovers. ( Let me know in comment section if you are )\\n\\n# Another Approach ( Using DP )\\n### What about the length 1 ?\\nYes, It will always be palindrome.\\n\\n### and What about length 2 ?\\nIt would be palindrome if only both are same.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/7acab936-a33c-462d-8f7e-e876f8f9accc_1707525295.7774024.png)\\n\\nnow let\\'s say I have one string f(a, b) = \"nitin\"\\nand I know that f(a+1, b-1) is palindrome, then if the boundary characters are same I can say that this is palindrome.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/cf5a83eb-1c3a-4d29-9c84-bd6c264cfa44_1707525366.0568507.png)\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/34fb54ba-cf7a-4537-ba99-4938f27e4f54_1707525385.051885.png)\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/ea355f42-44cf-40a3-86cf-ccd559ecf804_1707525405.3020074.png)\\n\\nHere we can say that if I know the answer for length 1, I can build the answer for length 3, how ?\\nSo basically  I just need to check boundary elements and middle one I already know if it palindrome or not.\\n\\nSo we will try to build from length 1 to n one by one and count the number of palindrome.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int countSubstrings(String s) {\\n        int n = s.length();\\n        boolean[][] palindrome = new boolean[n][n];\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            palindrome[i][i] = true;\\n            ans++;\\n        }\\n\\n        for(int i=0;i<n-1;i++) {\\n            if(s.charAt(i) == s.charAt(i+1)) {\\n                palindrome[i][i+1] = true;\\n                ans++;\\n            }\\n        }\\n\\n        for(int len=3;len<=n;len++) {\\n            for(int i=0;i<n-len+1;i++) {\\n                if(s.charAt(i) == s.charAt(i+len-1) && palindrome[i+1][i+len-2]) {\\n                    palindrome[i][i+len-1] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countSubstrings(string s) {\\n        int n = s.length();\\n        vector<vector<bool>> palindrome(n, vector<bool>(n, false));\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            palindrome[i][i] = true;\\n            ans++;\\n        }\\n\\n        for (int i = 0; i < n - 1; ++i) {\\n            if (s[i] == s[i + 1]) {\\n                palindrome[i][i + 1] = true;\\n                ans++;\\n            }\\n        }\\n\\n        for (int len = 3; len <= n; ++len) {\\n            for (int i = 0; i < n - len + 1; ++i) {\\n                if (s[i] == s[i + len - 1] && palindrome[i + 1][i + len - 2]) {\\n                    palindrome[i][i + len - 1] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def countSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        palindrome = [[False] * n for _ in range(n)]\\n        ans = 0\\n\\n        for i in range(n):\\n            palindrome[i][i] = True\\n            ans += 1\\n\\n        for i in range(n - 1):\\n            if s[i] == s[i + 1]:\\n                palindrome[i][i + 1] = True\\n                ans += 1\\n\\n        for length in range(3, n + 1):\\n            for i in range(n - length + 1):\\n                if s[i] == s[i + length - 1] and palindrome[i + 1][i + length - 2]:\\n                    palindrome[i][i + length - 1] = True\\n                    ans += 1\\n\\n        return ans\\n```\\n```JavaScript []\\n\/**\\n * @param {string} s\\n * @return {number}\\n *\/\\nvar countSubstrings = function(s) {\\n    const n = s.length;\\n    const palindrome = Array.from(Array(n), () => Array(n).fill(false));\\n    let ans = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        palindrome[i][i] = true;\\n        ans++;\\n    }\\n\\n    for (let i = 0; i < n - 1; i++) {\\n        if (s[i] === s[i + 1]) {\\n            palindrome[i][i + 1] = true;\\n            ans++;\\n        }\\n    }\\n\\n    for (let len = 3; len <= n; len++) {\\n        for (let i = 0; i < n - len + 1; i++) {\\n            if (s[i] === s[i + len - 1] && palindrome[i + 1][i + len - 2]) {\\n                palindrome[i][i + len - 1] = true;\\n                ans++;\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\nNow do you guys know who we are ? We are Coders and We write code that is best and clean as much as possible.\\n\\nSo I thought about the above solution and got to know that I can do this in one loop. But I just need to make sure I handle for len <= 2, because for that I don\\'t want to check any middle substring.\\n\\n```Java []\\nclass Solution {\\n    public int countSubstrings(String s) {\\n        int n = s.length();\\n        boolean[][] palindrome = new boolean[n][n];\\n        int ans = 0;\\n\\n        for(int len=1;len<=n;len++) {\\n            for(int i=0;i<n-len+1;i++) {\\n                if(s.charAt(i) == s.charAt(i+len-1) \\n                    && (len <= 2 || palindrome[i+1][i+len-2])) {\\n                    palindrome[i][i+len-1] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def countSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        palindrome = [[False] * n for _ in range(n)]\\n        ans = 0\\n\\n        for length in range(1, n + 1):\\n            for i in range(n - length + 1):\\n                if s[i] == s[i + length - 1] and (length <= 2 or palindrome[i + 1][i + length - 2]):\\n                    palindrome[i][i + length - 1] = True\\n                    ans += 1\\n\\n        return ans\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countSubstrings(string s) {\\n        int n = s.length();\\n        vector<vector<bool>> palindrome(n, vector<bool>(n, false));\\n        int ans = 0;\\n\\n        for (int len = 1; len <= n; ++len) {\\n            for (int i = 0; i < n - len + 1; ++i) {\\n                if (s[i] == s[i + len - 1] && (len <= 2 || palindrome[i + 1][i + len - 2])) {\\n                    palindrome[i][i + len - 1] = true;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n`Interviwer` : You are hired.\\n`You` : Thank you !!!\\n\\nIf you have came so far, Please upvote it !!!\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/b516f238-b777-471b-83b6-f0b3b8d81597_1707559973.0920436.png)\\n\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"},
{"prompt":"<p>Given the <code>head<\/code> of a singly linked list, return <code>true<\/code><em> if it is a <\/em><span data-keyword=\"palindrome-sequence\"><em>palindrome<\/em><\/span><em> or <\/em><code>false<\/code><em> otherwise<\/em>.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/03\/03\/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2,2,1]\n<strong>Output:<\/strong> true\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/03\/03\/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2]\n<strong>Output:<\/strong> false\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5<\/sup>]<\/code>.<\/li>\n\t<li><code>0 &lt;= Node.val &lt;= 9<\/code><\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<strong>Follow up:<\/strong> Could you do it in <code>O(n)<\/code> time and <code>O(1)<\/code> space?\n\n###\n\n","completion":" If I get 100 Upvotes on this post, I will post animated video on my channel for all the approaches.\\n\\n#### [Youtube Channel Link](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw)\\n\\n[Animation Link](https:\/\/www.youtube.com\/shorts\/HFtgsnD4rGY)\\n\\n\\nBefore moving forward, I just want to infrom you guys that I just got rating of 1960 in Leetcode, I mean I never thought. But since I got it I am setting new target for myself which is to get Guardian Badge. and approach is simple participate in contest and solve the question asap. ( I have never solved 4 questions in any contest, so I will try to solve leetcode hard problems from past contest to get insights ), Now let\\'s continue the blog.\\n\\n```Interview-Tip []\\nEvery Linked List Problem, if you can\\'t do it in LinkedList format,\\ncopy the data in list and now your question would become for an \\narray, solve it.\\n```\\n---\\n```Note []\\nCurrently code is in java only, \\nbut will be uploaded in different languages soon.\\n```\\n\\n#### [Reverse Linked List ( Yesterday\\'s Solution )](https:\/\/leetcode.com\/problems\/reverse-linked-list\/solutions\/4904297\/animated-solution-3-approach-recursion-two-pointer\/)\\n\\n# Approach ( Using List )\\n<!-- Describe your approach to solving the problem. -->\\nTo Check if the Given Linked List is palindrome or not , we can copy the data in list and then check if the list if palindrome or not.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(ListNode head) {\\n        List<Integer> list = new ArrayList();\\n        while(head != null) {\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n        \\n        int left = 0;\\n        int right = list.size()-1;\\n        while(left < right && list.get(left) == list.get(right)) {\\n            left++;\\n            right--;\\n        }\\n        return left >= right;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(ListNode* head) {\\n        vector<int> listVals;\\n        while (head) {\\n            listVals.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        int left = 0, right = listVals.size() - 1;\\n        while (left < right && listVals[left] == listVals[right]) {\\n            left++;\\n            right--;\\n        }\\n        return left >= right;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        list_vals = []\\n        while head:\\n            list_vals.append(head.val)\\n            head = head.next\\n        \\n        left, right = 0, len(list_vals) - 1\\n        while left < right and list_vals[left] == list_vals[right]:\\n            left += 1\\n            right -= 1\\n        return left >= right\\n```\\n```Javascript []\\nvar isPalindrome = function(head) {\\n    const listVals = [];\\n    while (head) {\\n        listVals.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    let left = 0, right = listVals.length - 1;\\n    while (left < right && listVals[left] === listVals[right]) {\\n        left++;\\n        right--;\\n    }\\n    return left >= right;\\n};\\n```\\n\\n# Approach#2 ( Using Stack )\\n\\nFirst push all data in stack, and then traverse linked list and keep popping element from stack one by one, so stack will give you element from last.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isPalindrome(ListNode head) {\\n        Stack<Integer> stack = new Stack();\\n        ListNode curr = head;\\n        while(curr != null) {\\n            stack.push(curr.val);\\n            curr = curr.next;\\n        }\\n        curr = head;\\n        while(curr != null && curr.val == stack.pop()) {\\n            curr = curr.next;\\n        }\\n        return curr == null;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isPalindrome(ListNode* head) {\\n        stack<int> stack;\\n        ListNode* curr = head;\\n        while (curr) {\\n            stack.push(curr->val);\\n            curr = curr->next;\\n        }\\n        curr = head;\\n        while (curr && curr->val == stack.top()) {\\n            stack.pop();\\n            curr = curr->next;\\n        }\\n        return curr == nullptr;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        list_vals = []\\n        stack = []\\n        curr = head\\n        while curr:\\n            stack.append(curr.val)\\n            curr = curr.next\\n        curr = head\\n        while curr and curr.val == stack.pop():\\n            curr = curr.next\\n        return curr is None\\n```\\n\\n# Approach#3 ( Using Recursion )\\n\\nAs you know, if any problem you can do using stack only then you can use recursion as well ( mostly ).\\n\\nSo we will have one global pointer as curr we will move this pointer once we reach the end and recursion will start from end of the list.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    ListNode curr;\\n    public boolean isPalindrome(ListNode head) {\\n        curr = head;\\n        return solve(head);\\n    }\\n\\n    public boolean solve(ListNode head) {\\n        if(head == null) return true;\\n        boolean ans = solve(head.next) && head.val == curr.val;\\n        curr = curr.next;\\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        self.curr = head\\n        return self.solve(head)\\n\\n    def solve(self, head: Optional[ListNode]) -> bool:\\n        if head is None:\\n            return True\\n        ans = self.solve(head.next) and head.val == self.curr.val\\n        self.curr = self.curr.next\\n        return ans\\n```\\n```C++ []\\nint init = [] {\\n    ios_base::sync_with_stdio(false);  cin.tie(nullptr);\\n    ofstream out(\"user.out\");\\n    for (string s; getline(cin, s);)\\n        out<<(equal(s.begin()+1, s.begin()+s.size()\/2, s.rbegin() + 1) ? \"true\\\\n\" : \"false\\\\n\");\\n    out.flush();\\n    exit(0);\\n    \\n    return 0;\\n}();\\n\\nclass Solution {\\n    ListNode* curr;\\npublic:\\n    bool isPalindrome(ListNode* head) {\\n        curr = head;\\n        return solve(head);\\n    }\\n\\n    bool solve(ListNode* head) {\\n        if (head == nullptr) return true;\\n        bool ans = solve(head->next) && head->val == curr->val;\\n        curr = curr->next;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n`Interview` : Can you come up with a solution with O(1) space ?\\n`You`: Sure. ( I already knew that )\\n\\n# Approach#4\\nThe main idea to check palindrome is , if the first and last elements are same or not and then check for second and second last.\\n\\nSo I am thinking what if I create new linked list which would be reversed of the original linked list.\\n\\nAnd then I can compare each element one by one.\\n\\n##### But do I need the whole linked list to reverse and compare ?\\nNo, I just need the second half of linked list to be reversed.\\n\\nNow the question is how can I get the second half ?\\nThere are two approach\\n1. Count all nodes first and then move to n\/2th node, this would be middle node.\\n2. Use two pointer one will move with the speed of 1 and one with the speed of 2, so when the fast pointer reaches the end, slow pointer would be at mid.\\n\\nAfter getting middle node, reverse the list after that node.\\nand then compare each element.\\n\\n# Code\\n```Java []\\nclass Solution {\\n\\n    public ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    public boolean isPalindrome(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode rev = reverse(slow.next); \/\/ reverse second list\\n        slow.next = null;\\n        while(rev != null) {\\n            if(head.val != rev.val) {\\n                return false;\\n            }\\n            head = head.next;\\n            rev = rev.next;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def reverse(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            next_temp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_temp\\n        return prev\\n\\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\\n        slow = head\\n        fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        rev = self.reverse(slow)\\n        while rev:\\n            if head.val != rev.val:\\n                return False\\n            head = head.next\\n            rev = rev.next\\n        return True\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    bool isPalindrome(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while (fast != nullptr && fast->next != nullptr) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* rev = reverse(slow);\\n        while (rev != nullptr) {\\n            if (head->val != rev->val) {\\n                return false;\\n            }\\n            head = head->next;\\n            rev = rev->next;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```Javascript []\\nfunction reverse(head) {\\n    let prev = null;\\n    let curr = head;\\n    while (curr) {\\n        let next = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n    return prev;\\n}\\n\\nvar isPalindrome = function(head) {\\n    let slow = head;\\n        let fast = head;\\n        while (fast && fast.next) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        let rev = reverse(slow);\\n        while (rev) {\\n            if (head.val !== rev.val) {\\n                return false;\\n            }\\n            head = head.next;\\n            rev = rev.next;\\n        }\\n        return true;\\n};\\n```\\n\\nIf you like this, please upvote it !\\n\\nRead other solutions\\n[143. Reorder List](https:\/\/leetcode.com\/problems\/reorder-list\/solutions\/4250201\/interview-approach-4-approaches\/?envType=daily-question&envId=2024-03-23)\\n\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"},
{"prompt":"<p>You are given a <code>rows x cols<\/code> matrix <code>grid<\/code> representing a field of cherries where <code>grid[i][j]<\/code> represents the number of cherries that you can collect from the <code>(i, j)<\/code> cell.<\/p>\n\n<p>You have two robots that can collect cherries for you:<\/p>\n\n<ul>\n\t<li><strong>Robot #1<\/strong> is located at the <strong>top-left corner<\/strong> <code>(0, 0)<\/code>, and<\/li>\n\t<li><strong>Robot #2<\/strong> is located at the <strong>top-right corner<\/strong> <code>(0, cols - 1)<\/code>.<\/li>\n<\/ul>\n\n<p>Return <em>the maximum number of cherries collection using both robots by following the rules below<\/em>:<\/p>\n\n<ul>\n\t<li>From a cell <code>(i, j)<\/code>, robots can move to cell <code>(i + 1, j - 1)<\/code>, <code>(i + 1, j)<\/code>, or <code>(i + 1, j + 1)<\/code>.<\/li>\n\t<li>When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.<\/li>\n\t<li>When both robots stay in the same cell, only one takes the cherries.<\/li>\n\t<li>Both robots cannot move outside of the grid at any moment.<\/li>\n\t<li>Both robots should reach the bottom row in <code>grid<\/code>.<\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/04\/29\/sample_1_1802.png\" style=\"width: 374px; height: 501px;\" \/>\n<pre>\n<strong>Input:<\/strong> grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\n<strong>Output:<\/strong> 24\n<strong>Explanation:<\/strong> Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/04\/23\/sample_2_1802.png\" style=\"width: 500px; height: 452px;\" \/>\n<pre>\n<strong>Input:<\/strong> grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\n<strong>Output:<\/strong> 28\n<strong>Explanation:<\/strong> Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>rows == grid.length<\/code><\/li>\n\t<li><code>cols == grid[i].length<\/code><\/li>\n\t<li><code>2 &lt;= rows, cols &lt;= 70<\/code><\/li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 100<\/code><\/li>\n<\/ul>\n\n\n###\n\n","completion":" ### Video Solution ( In Hindi Language )\\nWill be uploading soon !\\nhttps:\/\/youtu.be\/UrathtInxXg\\n\\nJust read the blog till end, I know it\\'s long but it will worth it.\\n\\n# Approach\\n`You` : Is there any cells have negative value ?\\n`Interviewer` : No\\n`You` : If both are on same place, only it would be counted once. if I am not wrong ?\\n`Interviewer` : Yes\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/0b38f3b9-4d15-4162-8f17-646f6a43900b_1707610368.8784027.png)\\n\\nSo Basically they should never cross each other, when they go into next row I will traverse all 3 possible column ( j-1, j, j+1 ) and will make sure they are in boundary as well as robot don\\'t colide with each other. ( Simple means if x is robotA position and y is robotB position then x < y always )\\n\\nOne more thing in diagram you can see B has come to the A and A went B, do we really need that ?\\nNo, Because the position B is holding A itself can reach that if it is optimal without intersecting with B. ( So they is no point of crossing each other )\\n\\nSo Basically I will use DFS here, starting from both robot and in each iteration I will go to next row with all possible columns.\\n\\n`You` : Can we code for this approach. It would be simple DFS.\\n`Interviewer` : Sure go head, later we can see if we can do any improvements.\\n\\nLet\\'s code\\n```Java []\\nclass Solution {\\n    \\n    public int cherryPickup(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        return helper(grid, 0, 0, cols-1);\\n    }\\n    \\n    public int helper(int[][] grid, int currRow, int robotACol, int robotBCol) {\\n        \\n        if(robotACol < 0 || robotBCol < 0 || robotACol >= grid[0].length || robotBCol >= grid[0].length) return 0;\\n        \\n        if(currRow == grid.length) return 0; \/\/ last row\\n        \\n        int result = 0;\\n        result += grid[currRow][robotACol];\\n        result += grid[currRow][robotBCol];\\n        \\n        int max = 0; \/\/ DFS for next row\\n        for(int x=robotACol-1;x<=robotACol+1;x++) {\\n            for(int y=robotBCol-1;y<=robotBCol+1;y++) {\\n                if(x < y) {\\n                    max = Math.max(max, helper(grid, currRow+1, x, y));\\n                }\\n            }\\n        }\\n        \\n        result += max; \/\/ add maximum result\\n        return result;\\n    }\\n}\\n```\\n\\nI\\'m excited to submit this , are you ?\\nLet\\'s submit then\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/2d70c6eb-b973-451f-b309-f1da60f48f35_1707610724.4688025.png)\\n\\n`You` : Oh my god ! It got TLE.\\n`Interviewer`: LOL !\\n`You` : I know you know it would get TLE ( MF )\\n`Interviewer` : Can you optimise it ?\\n`You` : Sure ( MF )\\n\\nSo here we can see that ( Remember that whenever you have recursion with more than 1 recursive function in it, It\\'s always possible that some of the recursive function we are re-calculating )\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/9e412cdb-47f7-49e4-ae78-8ae8745cfa69_1707611042.7585855.png)\\n\\nHere in above diagram you can clearly see, [2,3] already calculated when I was on [1,3] and it will be calculating again from [1,4] so I will store my result in an array.\\n\\nNow here we have 3 things that are changing,\\n1. current row\\n2. robotA col\\n3. robotB col\\nSo we will use 3D array to store our result.\\n\\nSo let\\'s code\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n    \\n    Integer memo[][][];\\n    \\n    public int cherryPickup(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        memo = new Integer[rows+1][cols+1][cols+1];\\n        return helper(grid, 0, 0, cols-1);\\n    }\\n    \\n    public int helper(int[][] grid, int currRow, int robotACol, int robotBCol) {\\n        \\n        if(robotACol < 0 || robotBCol < 0 || robotACol >= grid[0].length || robotBCol >= grid[0].length) return 0;\\n        \\n        if(currRow == grid.length) return 0;\\n        \\n        if(memo[currRow][robotACol][robotBCol] != null)\\n            return memo[currRow][robotACol][robotBCol];\\n        \\n        int result = 0;\\n        result += grid[currRow][robotACol];\\n        result += grid[currRow][robotBCol];\\n        \\n        int max = 0;\\n        for(int x=robotACol-1;x<=robotACol+1;x++) {\\n            for(int y=robotBCol-1;y<=robotBCol+1;y++) {\\n                if(x < y) { \/\/ they should not cross\\n                    max = Math.max(max, helper(grid, currRow+1, x, y));\\n                }\\n            }\\n        }\\n        \\n        result += max;\\n        return memo[currRow][robotACol][robotBCol] = result;\\n    }\\n}\\n```\\n\\nAnd it got passed.\\n`Interviewer` : Can we discuss time and space complexity for this approach.\\n`You` : Sure, so space complexity would be O(m*n^2) for memoization. where m is row and n is col. Time Complexity would also be the same here because we will fill this array, while traversing all possible columns.\\n\\n`Interviewer` : we have some time left, do you know about dynamic programming ?\\n`You` : Ya ! This solution is TOP DOWN DP approach.\\n`Interviewer` : Good, you know then can you convert this in bottom up approach.\\n`You` : Sure, I can try I mostly use TOP DOWN approach, let me change the code.\\n\\nLe Keyboard - ( TAPA TAPA TAPA .. )\\nhere is the code\\n```Java []\\nclass Solution {\\n    public int cherryPickup(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[][][] dp = new int[m][n][n];\\n        int ans = 0;\\n\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                Arrays.fill(dp[i][j], -1);\\n\\n        dp[0][0][n-1] = grid[0][0] + grid[0][n-1];\\n\\n        for(int i=1;i<m;i++) {\\n            for(int j=0;j<n;j++) { \/\/ robotA\\n                for(int k=j+1;k<n;k++) { \/\/ robotB\\n                    int max = -1;\\n                    for(int x=-1;x<=1;x++) { \/\/ we will have total 9 combinations\\n                        for(int y=-1;y<=1;y++) {\\n                            if(j+x >= 0 && j+x < n && k+y >= 0 && k+y < n)\\n                                max = Math.max(\\n                                    max,\\n                                    dp[i-1][j+x][k+y]\\n                                );\\n                        }\\n                    }\\n                    if(max != -1)\\n                        dp[i][j][k] = max + grid[i][j] + grid[i][k];\\n                    if(ans < dp[i][j][k]) ans = dp[i][j][k];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int cherryPickup(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(n, -1)));\\n        dp[0][0][n-1] = grid[0][0] + grid[0][n-1];\\n\\n        int ans = 0;\\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) { \/\/ robotA\\n                for(int k = j+1; k < n; ++k) { \/\/ robotB\\n                    for(int x = -1; x <= 1; ++x) { \/\/ x and y all possible combinations\\n                        for(int y = -1; y <= 1; ++y) {\\n                            int nj = j + x, nk = k + y;\\n                            if(nj >= 0 && nj < n && nk >= 0 && nk < n) {\\n                                int prev = dp[i-1][nj][nk];\\n                                if(prev != -1) {\\n                                    dp[i][j][k] = max(dp[i][j][k], prev + grid[i][j] + (j != k ? grid[i][k] : 0));\\n                                }\\n                            }\\n                        }\\n                    }\\n                    if(ans < dp[i][j][k]) ans = dp[i][j][k];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def cherryPickup(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp = [[[-1] * n for _ in range(n)] for _ in range(m)]\\n        dp[0][0][n-1] = grid[0][0] + grid[0][n-1]\\n\\n        for i in range(1, m):\\n            for j in range(n):\\n                for k in range(j+1, n):\\n                    for x in range(-1, 2):\\n                        for y in range(-1, 2):\\n                            if 0 <= j+x < n and 0 <= k+y < n:\\n                                prev = dp[i-1][j+x][k+y]\\n                                if prev != -1:\\n                                    dp[i][j][k] = max(dp[i][j][k], prev + grid[i][j] + (grid[i][k] if j != k else 0))\\n\\n        ans = max(max(row) for row in dp[m-1])\\n        return ans if ans != -1 else 0\\n```\\n\\n`Interviewer` : will it have the same time and space complexity as top down.\\n`You` : Yes, we still have to fill all those states.\\n`Interviewer` : Can you optimise it more ?\\n`You` : Ok, let me think. ( Thinking .. ) As of now I am not able to think of any approach which can have better time complexity than this.\\n`Interviwer` : Ok, What about space ?\\n`You` : Space Complexity. Yes yes I got it. ( Because MF I already knew you would ask me this question. ) As we can see that for any current row we are just dependent on previous row and all other rows are of no use. So we just need two rows.\\nLet\\'s say I can have two array, prev and curr. And every time when I go to new row this curr would become prev.\\nBut I can do this using array of length 2.\\nwhere for previous row, I can do (i+1)%2 means if I am at 0th row my previous would be at 1 and when I am at 1 my previous would be 0.\\n`Interviewer` : Can you modify you previous approach with this.\\n`You` : Sure.\\n\\n```Java []\\nclass Solution {\\n    public int cherryPickup(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[][][] dp = new int[2][n][n];\\n        int ans = 0;\\n\\n        for(int i=0;i<2;i++)\\n            for(int j=0;j<n;j++)\\n                Arrays.fill(dp[i][j], -1);\\n\\n        dp[0][0][n-1] = grid[0][0] + grid[0][n-1];\\n\\n        for(int i=1;i<m;i++) {\\n            for(int j=0;j<n;j++) { \/\/ robotA\\n                for(int k=j+1;k<n;k++) { \/\/ robotB\\n                    int max = -1;\\n                    for(int x=-1;x<=1;x++) { \/\/ we will have total 9 combinations\\n                        for(int y=-1;y<=1;y++) {\\n                            if(j+x >= 0 && j+x < n && k+y >= 0 && k+y < n)\\n                                max = Math.max(\\n                                    max,\\n                                    dp[(i+1)%2][j+x][k+y]\\n                                );\\n                        }\\n                    }\\n                    if(max != -1)\\n                        dp[i%2][j][k] = max + grid[i][j] + grid[i][k];\\n                    if(ans < dp[i%2][j][k]) ans = dp[i%2][j][k];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n`Interviewer` : Ok ! We still have some time left. Do you have any questions for me ?\\n`You` : Yes ( MF , JSUT HIRE ME ) , What motivates you to work at this XYZ company ?\\n`Interviwer` : ( Blaah , Blaah , Blaah !!! )\\n`You` : Thanks !!! ( Hang Up )\\n\\n( Calling Mother ... Ring Ring Ring , \\nDear Mama You Son will be fulfilling your all wishes ! )\\n\\n---\\n\\nIf you understand this blog, try these questions ( Please , It\\'s my humble request if you also want to fulfill you parent\\'s wishes like me )\\n1. [62. Unique Paths](https:\/\/leetcode.com\/problems\/unique-paths\/description\/)\\n2. [63. Unique Paths II](https:\/\/leetcode.com\/problems\/unique-paths-ii\/description\/)\\n3. [980. Unique Paths III](https:\/\/leetcode.com\/problems\/unique-paths-iii\/description\/)\\n4. [2304. Minimum Path Cost in a Grid](https:\/\/leetcode.com\/problems\/minimum-path-cost-in-a-grid\/description\/)\\n5. [174. Dungeon Game](https:\/\/leetcode.com\/problems\/dungeon-game\/description\/) `This one is tough to crack but you can try at least and It\\'s most likely to be asked in an interview. )`\\n6. [741. Cherry Pickup](https:\/\/leetcode.com\/problems\/cherry-pickup\/description\/)\\n\\n---\\n\\nIf you have came so far, upvote it !!!\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/b516f238-b777-471b-83b6-f0b3b8d81597_1707559973.0920436.png)\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"},
{"prompt":"<p>You are given an integer array <code>heights<\/code> representing the heights of buildings, some <code>bricks<\/code>, and some <code>ladders<\/code>.<\/p>\n\n<p>You start your journey from building <code>0<\/code> and move to the next building by possibly using bricks or ladders.<\/p>\n\n<p>While moving from building <code>i<\/code> to building <code>i+1<\/code> (<strong>0-indexed<\/strong>),<\/p>\n\n<ul>\n\t<li>If the current building&#39;s height is <strong>greater than or equal<\/strong> to the next building&#39;s height, you do <strong>not<\/strong> need a ladder or bricks.<\/li>\n\t<li>If the current building&#39;s height is <b>less than<\/b> the next building&#39;s height, you can either use <strong>one ladder<\/strong> or <code>(h[i+1] - h[i])<\/code> <strong>bricks<\/strong>.<\/li>\n<\/ul>\n\n<p><em>Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.<\/em><\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/10\/27\/q4.gif\" style=\"width: 562px; height: 561px;\" \/>\n<pre>\n<strong>Input:<\/strong> heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1\n<strong>Output:<\/strong> 4\n<strong>Explanation:<\/strong> Starting at building 0, you can follow these steps:\n- Go to building 1 without using ladders nor bricks since 4 &gt;= 2.\n- Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 &lt; 7.\n- Go to building 3 without using ladders nor bricks since 7 &gt;= 6.\n- Go to building 4 using your only ladder. You must use either bricks or ladders because 6 &lt; 9.\nIt is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2\n<strong>Output:<\/strong> 7\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> heights = [14,3,19,3], bricks = 17, ladders = 0\n<strong>Output:<\/strong> 3\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>1 &lt;= heights[i] &lt;= 10<sup>6<\/sup><\/code><\/li>\n\t<li><code>0 &lt;= bricks &lt;= 10<sup>9<\/sup><\/code><\/li>\n\t<li><code>0 &lt;= ladders &lt;= heights.length<\/code><\/li>\n<\/ul>\n\n\n###\n\n","completion":" ### Subscribe To Our Channel\\nhttps:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw\/\\n\\n```Disclaimer []\\nThis post is for those ** who just start coding without taking\\ninput size into consideration.\\n```\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/2494ac15-b3dd-42ab-a092-97375c5a73bb_1708162311.870668.png)\\n\\n# Approach\\n```Note []\\nTwo points to note here\\n1. If the next building is on lower or equal height I can move on.\\n\\n2. If the next building is higher than I have two choices \\nI can use ladder or I can use no. of bricks of that height difference.\\n```\\n\\nIf you are the DP lover, you might be co-relating this problem with knapsack like we have two choice either we can use ladder or we can use bricks.\\nAnd some of you might have started writing recursion and when you went for memoization you got to know that you will need 3D DP for sure. But the size is so large that you will get `Memory Limit Exceeded`. Although I am sharing code for this just for your info.\\n\\n```Java []\\nclass Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        int n = heights.length;\\n        return solve(heights, 0, bricks, ladders);\\n    }\\n\\n    public int solve(int[] heights, int i, int bricks, int ladders) {\\n        if(i == heights.length-1) return i;\\n        int diff = heights[i+1] - heights[i];\\n        if(diff > 0) {\\n            int ans = i;\\n            if(bricks >= diff) {\\n                ans = Math.max(ans, solve(heights, i+1, bricks - diff, ladders));\\n            }\\n            if(ladders > 0) {\\n                ans = Math.max(ans, solve(heights, i+1, bricks, ladders-1));\\n            }\\n            return ans;\\n        } else {\\n            return solve(heights, i+1, bricks, ladders);\\n        }\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\\n        int n = heights.size();\\n        return solve(heights, 0, bricks, ladders, n);\\n    }\\n\\n    int solve(const vector<int>& heights, int i, int bricks, int ladders, int n) {\\n        if (i == n - 1) return i;\\n        int diff = heights[i + 1] - heights[i];\\n        if (diff > 0) {\\n            int ans = i;\\n            if (bricks >= diff) {\\n                ans = max(ans, solve(heights, i + 1, bricks - diff, ladders, n));\\n            }\\n            if (ladders > 0) {\\n                ans = max(ans, solve(heights, i + 1, bricks, ladders - 1, n));\\n            }\\n            return ans;\\n        } else {\\n            return solve(heights, i + 1, bricks, ladders, n);\\n        }\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\\n        n = len(heights)\\n        return self.solve(heights, 0, bricks, ladders)\\n\\n    def solve(self, heights: List[int], i: int, bricks: int, ladders: int) -> int:\\n        if i == len(heights) - 1:\\n            return i\\n        diff = heights[i + 1] - heights[i]\\n        if diff > 0:\\n            ans = i\\n            if bricks >= diff:\\n                ans = max(ans, self.solve(heights, i + 1, bricks - diff, ladders))\\n            if ladders > 0:\\n                ans = max(ans, self.solve(heights, i + 1, bricks, ladders - 1))\\n            return ans\\n        else:\\n            return self.solve(heights, i + 1, bricks, ladders)\\n```\\n\\nIt will give TLE. Because we haven\\'t done memoization. Let\\'s do memoization\\n\\n```Java []\\nclass Solution {\\n\\n    Integer[][][] memo;\\n\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        int n = heights.length;\\n        memo = new Integer[n+1][bricks+1][ladders+1];\\n        return solve(heights, 0, bricks, ladders);\\n    }\\n\\n    public int solve(int[] heights, int i, int bricks, int ladders) {\\n        if(i == heights.length-1) return i;\\n        \\n        if(memo[i][bricks][ladders] != null) return memo[i][bricks][ladders];\\n\\n        int diff = heights[i+1] - heights[i];\\n        if(diff > 0) {\\n            int ans = i;\\n            if(bricks >= diff) {\\n                ans = Math.max(ans, solve(heights, i+1, bricks - diff, ladders));\\n            }\\n            if(ladders > 0) {\\n                ans = Math.max(ans, solve(heights, i+1, bricks, ladders-1));\\n            }\\n            return memo[i][bricks][ladders] = ans;\\n        } else {\\n            return memo[i][bricks][ladders] = solve(heights, i+1, bricks, ladders);\\n        }\\n    }\\n}\\n```\\n\\nAlthough I have checked the input size that it would give me Memory Limit, I thought of giving it a try.\\n\\nAnd yes, I got `Memory Limit Exceeded` .\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/642697d3-80bc-436f-a0c9-b652a425dad4_1708137543.2436063.png)\\n\\nSo Now you need to remember one thing for rest of your life\\n\\n```Rule#96 []\\nGREEDY >>>> DP ( Sorry DP lovers )\\n\\nWhenever you apply DP in any question, first always try to make this\\nusing simple greedy approach. If greedy fails then go for DP.\\n\\nBecause for DP either you might require O(n^2) or \\nsometime for 3D dp O(n^3) time. \\n\\nBut in greedy which mostly work by sorting data it will be \\nin O(n*logn). \\n\\nIf you closely check the input size is 10^5 so for sure \\nwe have to do this in O(nlogn) or lower time.\\n```\\n\\nHere it\\'s not like I have choice either I can pick ladder or brick, I also need to make sure I reach the maximum index.\\n\\nSo let\\'s say you have to climb 8 and 2, and you have 5 bricks and 1 ladder.\\n\\nWhat will you do ?\\nObviously you will try to climb the highest using ladder else you will waste too many bricks.\\n\\n```Conclusion []\\nSo here we know that we will use ladders for the highest \\nclimb and bricks for the remaining.\\n```\\n\\nNow here comes the best part \\nHow will you manage this, like for the highest climb you are using ladders and for other you are using bricks.\\n\\n1. First of all as we climb one by one, we will use ladders till we are out of ladders.\\n2. Now when we have consumed our all ladders, now it\\'s our turn to use bricks. Now let\\'s say previously we have use ladders to climb [4, 10, 6] and now we have to climb 5, so now I know that for 5 I should use ladder, and the previously I have used ladder for 4 I will use brick there.\\n3. So now ladders will be used to climb [10, 6, 5] and bricks for [4].\\n4. Now let\\'s say I have to climb 2, then obviously I can\\'t use ladders because they are already being used to climb high. SO I will use bricks here. But let\\'s say I have one 1 brick left then I won\\'t be able to climb further.\\n\\nNow if you have read all 4 points clearly, you got to know that if the climb is lower or equal to the climb made by ladders then we can use brick.\\nbut if we found high climb where previously we have used ladders for the lower climb, I will use ladders here and bricks there.\\n\\n```Final []\\nSo everytime, I am picking up minimum from ladders if it is less \\nor equal to the current climb, I will just use bricks.\\nElse I will remove the minimum and insert new climb in ladders and \\nfor the removed climb ( min. from ladders ) I will use bricks.\\n```\\n\\nSo now every time I need to remove minimum so I can use min-heap here of size ladders.\\n\\nLet\\'s code now\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        int n = heights.length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int i=0;i<n-1;i++) {\\n            int diff = heights[i+1] - heights[i];\\n            if(diff > 0) {\\n                if(pq.size() < ladders) {\\n                    pq.add(diff);\\n                } else {\\n                    if(pq.isEmpty() || pq.peek() >= diff) {\\n                        bricks -= diff;\\n                    } else {\\n                        int poll = pq.poll();\\n                        pq.add(diff);\\n                        bricks -= poll;\\n                    }\\n                    if(bricks < 0) return i;\\n                }\\n            }\\n        }\\n        return n-1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\\n        n = len(heights)\\n        pq = []\\n        for i in range(n-1):\\n            diff = heights[i+1] - heights[i]\\n            if diff > 0:\\n                if len(pq) < ladders:\\n                    heappush(pq, diff)\\n                else:\\n                    if not pq or pq[0] >= diff:\\n                        bricks -= diff\\n                    else:\\n                        poll = heappop(pq)\\n                        heappush(pq, diff)\\n                        bricks -= poll\\n                    if bricks < 0:\\n                        return i\\n        return n-1\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {\\n        int n = heights.size();\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < n - 1; ++i) {\\n            int diff = heights[i + 1] - heights[i];\\n            if (diff > 0) {\\n                if (pq.size() < ladders) {\\n                    pq.push(diff);\\n                } else {\\n                    if (pq.empty() || pq.top() >= diff) {\\n                        bricks -= diff;\\n                    } else {\\n                        int poll = pq.top(); pq.pop();\\n                        pq.push(diff);\\n                        bricks -= poll;\\n                    }\\n                    if (bricks < 0) return i;\\n                }\\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n*logk) where k = ladders because heap size would always be k.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```Rule#97 []\\nAs a Software Engineer, I work on three principles - \\n1. Make it work ( write brute force )\\n2. Optimise it ( optimise the brute force )\\n3. Clean it ( clean the optimised code )\\n```\\n\\nNow we have optimised our code and there is no further optimisation I can see\\n\\nSo now I will work on making this code more cleaner.\\n```TIP []\\nBecause the code we write is mostly read by humans than leetcode\\ncompiler.\\n```\\n\\nSo let\\'s write clean code for it ( If you have understood previous solution, it won\\'t be hard to figure this out )\\n\\n```Java []\\nclass Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int i=0;i<heights.length-1;i++) {\\n            int diff = heights[i+1] - heights[i];\\n            if(diff <= 0) continue;\\n            pq.add(diff);\\n            if(pq.size() > ladders) bricks -= pq.poll();\\n            if(bricks < 0) return i;\\n        }\\n        return heights.length-1;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int furthestBuilding(vector<int>& h, int b, int l) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < h.size() - 1; ++i) {\\n            int diff = h[i + 1] - h[i];\\n            if (diff <= 0) continue;\\n            pq.push(diff);\\n            if (pq.size() > l) {\\n                b -= pq.top(); pq.pop();\\n            }\\n            if (b < 0) return i;\\n        }\\n        return h.size() - 1;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -> int:\\n        pq = []\\n        for i in range(len(heights) - 1):\\n            diff = heights[i + 1] - heights[i]\\n            if diff <= 0:\\n                continue\\n            heappush(pq, diff)\\n            if len(pq) > ladders:\\n                bricks -= heappop(pq)\\n            if bricks < 0:\\n                return i\\n        return len(heights) - 1\\n```\\n\\nTime & Space Complexity would be same as previous.\\n\\nNow one more thing before I close this post, in above approach we have take heap to store minimum in heap because we will use ladders for maximum.\\nYou can take maximum heap which will store bricks because we want minimum bricks to be used.\\n\\n```Rule#99 []\\nSo as a programmer, you should think from all sides.\\n```\\n\\nNow for beginners, who don\\'t know what is priority queue, you can use an array of size k ( ladders ) and it should be sorted. So that your first element is always minimum. So if you want to insert new element either you can update it at first index and again sort it. But if you know binary search than you can find the position to insert in array and then shift elements so that it is still sorted. ( But I would recommend you read about priority queue, It\\'s not a rocket science. )\\n\\n```Summary []\\n1. Before going for DP, try to think atleast from greedy persepective.\\n2. You can use min-heap of size k to always maintain the data having\\n   value more than m ( where m is minimum ). So your m would be the \\n   k largest element here. ( Try to read K largest or K smallest ).\\n```\\n\\nThat\\'s all from my side ...\\n\\nNow I\\'ve one tip for you guys\\n```Rule#100 []\\nBe Calm and Crack Jokes in Tough Situations as well !!!\\n\\nIf you are software engineer, or in the road of becoming.\\nThere would be sometimes when something bad happens or some\\nbug that will ruin your whole day \/ week.\\n\\nBut Remember one thing no matter what happens, even if you lose\\nthe job or you done something wrong on production. \\nNot only you if your juniors do something terribly wrong. \\nFirst try to solve it asap and handle the sitation calmly.\\n\\nDon\\'t loose your humour in any situations.\\n```\\n\\nIf you have come so far, Please upvote it !!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"},
{"prompt":"<p>Given an array of integers <code>nums<\/code> containing&nbsp;<code>n + 1<\/code> integers where each integer is in the range <code>[1, n]<\/code> inclusive.<\/p>\n\n<p>There is only <strong>one repeated number<\/strong> in <code>nums<\/code>, return <em>this&nbsp;repeated&nbsp;number<\/em>.<\/p>\n\n<p>You must solve the problem <strong>without<\/strong> modifying the array <code>nums<\/code>&nbsp;and using only constant extra space.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [1,3,4,2,2]\n<strong>Output:<\/strong> 2\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,1,3,4,2]\n<strong>Output:<\/strong> 3\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,3,3,3,3]\n<strong>Output:<\/strong> 3<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums.length == n + 1<\/code><\/li>\n\t<li><code>1 &lt;= nums[i] &lt;= n<\/code><\/li>\n\t<li>All the integers in <code>nums<\/code> appear only <strong>once<\/strong> except for <strong>precisely one integer<\/strong> which appears <strong>two or more<\/strong> times.<\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<p><b>Follow up:<\/b><\/p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums<\/code>?<\/li>\n\t<li>Can you solve the problem in linear runtime complexity?<\/li>\n<\/ul>\n\n\n###\n\n","completion":" ### [Subscribe to My Channel ( Target 1K Subscribers )](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw)\\n\\n## Video Solution\\nI will be live today around 12:30 PM [here](https:\/\/www.youtube.com\/watch?v=wIRzisDcFSE&ab_channel=CSIITIAN)\\nhttps:\/\/www.youtube.com\/watch?v=wIRzisDcFSE&ab_channel=CSIITIAN\\n\\nOnly Approach#5 and Approach#7 has code in C++, Java, Python3 and Javascript.\\n\\n# 1. Brute Force ( TLE )\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i] == nums[j]) return nums[i];\\n        return -1;\\n    }\\n}\\n```\\n\\n# 2. Sort the array and check adjacent elements\\nTime Complexity: O(n*logn)\\nSpace Complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n            if(nums[i] == nums[i+1]) return nums[i];\\n        return -1;\\n    }\\n}\\n```\\n\\n# 3. Using HashSet to store visited nodes\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        for(int i=0;i<nums.length;i++) {\\n            if(set.contains(nums[i])) return nums[i];\\n            set.add(nums[i]);\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# 4. Using boolean array\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        boolean[] set = new boolean[n+1];\\n        for(int i=0;i<n;i++) {\\n            if(set[nums[i]]) return nums[i];\\n            set[nums[i]] = true;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```Note []\\nIn Approach 5 and 6, you might be thinking how we can do that,\\nsince we are not allowed to modify the existing array.\\nDon\\'t worry, once we perform answer we can revert the changes.\\nI haven\\'t written code for that.\\n```\\n\\n# 5. Mark visited element negative\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            int ind = abs(nums[i]);\\n            if (nums[ind] < 0) {\\n                return ind;\\n            }\\n            nums[ind] = -nums[ind];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++) {\\n            int ind = Math.abs(nums[i]);\\n            if(nums[ind] < 0) {\\n                return ind;\\n            }\\n            nums[ind] = -nums[ind];\\n        }\\n        return -1;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            ind = abs(nums[i])\\n            if nums[ind] < 0:\\n                return ind\\n            nums[ind] = -nums[ind]\\n        return -1\\n```\\n```Javascript []\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    for (let i = 0; i < nums.length; i++) {\\n        let ind = Math.abs(nums[i]);\\n        if (nums[ind] < 0) {\\n            return ind;\\n        }\\n        nums[ind] = -nums[ind];\\n    }\\n    return -1;\\n};\\n```\\n\\n# 6. Using Mod ( 1e5 + 1 )\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int mod = (int)1e5 + 1;\\n        for(int i=0;i<nums.length;i++) {\\n            int ind = Math.abs(nums[i])%mod;\\n            if(nums[ind]\/mod > 0) {\\n                return ind;\\n            }\\n            nums[ind] += mod;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# 7. Hare & Tortoise Method\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        fast = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return fast;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do { \/\/ we are sure that at least one duplicate is there\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while(slow != fast);\\n        \/\/ find the head of loop\\n        fast = nums[0];\\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return fast;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        fast = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return fast\\n```\\n```Javascript []\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n    do {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    } while (slow != fast);\\n    \\n    fast = nums[0];\\n    while (slow != fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    return fast;\\n};\\n```\\n\\nIf you have come so far, don\\'t forget to upvote the post !\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"},
{"prompt":"<p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly<\/i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.<\/p>\n\n<p>Given a tree of <code>n<\/code> nodes&nbsp;labelled from <code>0<\/code> to <code>n - 1<\/code>, and an array of&nbsp;<code>n - 1<\/code>&nbsp;<code>edges<\/code> where <code>edges[i] = [a<sub>i<\/sub>, b<sub>i<\/sub>]<\/code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i<\/sub><\/code> and&nbsp;<code>b<sub>i<\/sub><\/code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x<\/code> as the root, the result tree has height <code>h<\/code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)<\/code>)&nbsp; are called <strong>minimum height trees<\/strong> (MHTs).<\/p>\n\n<p>Return <em>a list of all <strong>MHTs&#39;<\/strong> root labels<\/em>.&nbsp;You can return the answer in <strong>any order<\/strong>.<\/p>\n\n<p>The <strong>height<\/strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/09\/01\/e1.jpg\" style=\"width: 800px; height: 213px;\" \/>\n<pre>\n<strong>Input:<\/strong> n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>Output:<\/strong> [1]\n<strong>Explanation:<\/strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/09\/01\/e2.jpg\" style=\"width: 800px; height: 321px;\" \/>\n<pre>\n<strong>Input:<\/strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>Output:<\/strong> [3,4]\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4<\/sup><\/code><\/li>\n\t<li><code>edges.length == n - 1<\/code><\/li>\n\t<li><code>0 &lt;= a<sub>i<\/sub>, b<sub>i<\/sub> &lt; n<\/code><\/li>\n\t<li><code>a<sub>i<\/sub> != b<sub>i<\/sub><\/code><\/li>\n\t<li>All the pairs <code>(a<sub>i<\/sub>, b<sub>i<\/sub>)<\/code> are distinct.<\/li>\n\t<li>The given input is <strong>guaranteed<\/strong> to be a tree and there will be <strong>no repeated<\/strong> edges.<\/li>\n<\/ul>\n\n\n###\n\n","completion":" ## Subscribe to My Channel ( Target : 1K )\\nhttps:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw\\n\\n# Approach\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/8ec76bc8-0331-4529-ac33-20a0c805d484_1713833772.2551377.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/227896ab-95b0-4283-9403-bb9f726a9f0f_1713833806.6421852.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/085bd2e8-bc51-4d16-a61a-e53e30f03803_1713833840.6502717.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/0938034b-cf00-452d-9561-374972c74a86_1713833883.439522.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/280c1dfe-282e-484b-89e9-a28a625a78d0_1713833908.8626156.png)\\n\\n\\n# Code Explanation\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/82ceedf6-5188-42e7-bdcd-24a36c8ed585_1713834144.6413438.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n == 1) return Collections.singletonList(0);\\n        \\n        int ind[] = new int[n];\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        for(int[] edge: edges) {\\n            ind[edge[0]]++;\\n            ind[edge[1]]++;\\n            map.putIfAbsent(edge[0], new ArrayList());\\n            map.putIfAbsent(edge[1], new ArrayList());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Queue<Integer> queue = new LinkedList();\\n        for(int i=0;i<ind.length;i++) {\\n            if(ind[i] == 1) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        int processed = 0;\\n        while(n - processed > 2) {\\n            int size = queue.size();\\n            processed += size;\\n            for(int i=0;i<size;i++) {\\n                int poll = queue.poll();\\n                for(int adj: map.get(poll)) {\\n                    if(--ind[adj] == 1) {\\n                        queue.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList();\\n        list.addAll(queue);\\n        return list;\\n    }\\n}\\n```\\n\\n\\n# Optimised Code ( by Chat GPT )\\n\\n```java []\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n        \\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n            adjacencyList.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(edge[1]);\\n            adjacencyList.computeIfAbsent(edge[1], x -> new ArrayList<>()).add(edge[0]);\\n        }\\n\\n        Queue<Integer> leaves = new LinkedList<>();\\n        for (int i = 0; i < degree.length; i++) {\\n            if (degree[i] == 1) {\\n                leaves.add(i);\\n            }\\n        }\\n\\n        int remainingNodes = n;\\n        while (remainingNodes > 2) {\\n            int size = leaves.size();\\n            remainingNodes -= size;\\n            for (int i = 0; i < size; i++) {\\n                int leaf = leaves.poll();\\n                for (int neighbor : adjacencyList.get(leaf)) {\\n                    if (--degree[neighbor] == 1) {\\n                        leaves.add(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(leaves);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) return {0};\\n    \\n        std::vector<std::list<int>> adjacency_list(n);\\n        std::vector<int> degree(n, 0);\\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adjacency_list[u].push_back(v);\\n            adjacency_list[v].push_back(u);\\n            degree[u]++;\\n            degree[v]++;\\n        }\\n        \\n        std::queue<int> leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (degree[i] == 1) leaves.push(i);\\n        }\\n        \\n        int remainingNodes = n;\\n        while (remainingNodes > 2) {\\n            int leavesCount = leaves.size();\\n            remainingNodes -= leavesCount;\\n            for (int i = 0; i < leavesCount; ++i) {\\n                int leaf = leaves.front();\\n                leaves.pop();\\n                for (int neighbor : adjacency_list[leaf]) {\\n                    if (--degree[neighbor] == 1) {\\n                        leaves.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        std::vector<int> result;\\n        while (!leaves.empty()) {\\n            result.push_back(leaves.front());\\n            leaves.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        \\n        # Initialize the adjacency list and degree of each node\\n        adjacency_list = defaultdict(list)\\n        degree = [0] * n\\n        for u, v in edges:\\n            adjacency_list[u].append(v)\\n            adjacency_list[v].append(u)\\n            degree[u] += 1\\n            degree[v] += 1\\n        \\n        # Initialize leaves queue\\n        leaves = deque([i for i in range(n) if degree[i] == 1])\\n        \\n        # Trim leaves until 2 or fewer nodes remain\\n        remaining_nodes = n\\n        while remaining_nodes > 2:\\n            leaves_count = len(leaves)\\n            remaining_nodes -= leaves_count\\n            for _ in range(leaves_count):\\n                leaf = leaves.popleft()\\n                for neighbor in adjacency_list[leaf]:\\n                    degree[neighbor] -= 1\\n                    if degree[neighbor] == 1:\\n                        leaves.append(neighbor)\\n        \\n        return list(leaves)\\n```\n"},
{"prompt":"<p>You are given a <strong>0-indexed<\/strong> integer array <code>nums<\/code> of <strong>even<\/strong> length consisting of an <strong>equal<\/strong> number of positive and negative integers.<\/p>\n\n<p>You should return the array of nums such that the the array follows the given conditions:<\/p>\n\n<ol>\n\t<li>Every <strong>consecutive pair<\/strong> of integers have <strong>opposite signs<\/strong>.<\/li>\n\t<li>For all integers with the same sign, the <strong>order<\/strong> in which they were present in <code>nums<\/code> is <strong>preserved<\/strong>.<\/li>\n\t<li>The rearranged array begins with a positive integer.<\/li>\n<\/ol>\n\n<p>Return <em>the modified array after rearranging the elements to satisfy the aforementioned conditions<\/em>.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,1,-2,-5,2,-4]\n<strong>Output:<\/strong> [3,-2,1,-5,2,-4]\n<strong>Explanation:<\/strong>\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  \n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [-1,1]\n<strong>Output:<\/strong> [1,-1]\n<strong>Explanation:<\/strong>\n1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1].\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums.length<\/code> is <strong>even<\/strong><\/li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums<\/code> consists of <strong>equal<\/strong> number of positive and negative integers.<\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\nIt is not required to do the modifications in-place.\n\n###\n\n","completion":" Hi Everyone, Welcome back to our interview series !\\n\\n## Video Solution\\nhttps:\/\/youtu.be\/S-VLkFLOaWA\\n\\nSo if this question has been asked to you then it means you will most likely to get followed question as what if the order doesn\\'t matter.\\nMeans you just have to put positive and negative in alternative order.\\nEx: [4, -2, -5, 9]\\nSo your answer could be [4, -5, 9, 2] since order doesn\\'t matter.\\n\\nSo first let\\'s focus on the question where order matters.\\n\\n```Note []\\nNo. of positives = No. of negatives\\nSo if I start first from positive if will end at negative. \\nor Either I can start first from negative.\\nWe will follow first one , which is starting from positive.\\nSo next positive would be after 2 index and so on in the gap of 2.\\nOur negative would start from 1 and would step up by 2 each time.\\n```\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/1c2dda55-157f-4129-a8cd-30628727fb39_1707874686.247468.png)\\n\\n\\nSince we have fixed index for positive and negative. I can fetch the positives and negatives in an array and then one by one put into result array.\\n\\n```DryRun []\\nEx: [3,1,-2,-5,2,-4]\\nPos: [3, 1, 2]\\nNeg: [-2, -5, -4]\\n\\nNow put all positives at even place\\nresult: [3, _, 1, _, 2, _] ( here _ means we have not inserted)\\nNow put all negatives at odd place\\nresult: [3, -2, 1, -5, 2, -4]\\n\\nSo we can see that now positive are all at even index and negatives\\nare all at odd index in their original order.\\n```\\n\\n`You` : Are we good with this approach ?\\n`Interviewer`: Let\\'s discuss time and space complexity, then we can go ahead.\\n`You` : Space Compelxity would be O(n) to store positives and negatives. and Time Complexity would also be O(n) we will traverse each element twice. Once for filling in positives and negatives list and second time for inserting into result array at their specified position.\\n`Interviewer` : Cool ! Then write code for it.\\n\\n*Le Keyboard: (TAPA, TAP, TAPA, TAP ... )\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        List<Integer> pos = new ArrayList();\\n        List<Integer> neg = new ArrayList();\\n        \\n        for(int x: nums) {\\n            if(x >= 0) pos.add(x);\\n            else neg.add(x);\\n        }\\n\\n        for(int i=0;i<nums.length;i++) {\\n            if(i%2 == 0) {\\n                nums[i] = pos.get(i\/2);\\n            } else {\\n                nums[i] = neg.get(i\/2);\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\\n\\n`Interviewer` : Here you have used two iteration, can you do it in one iterations ?\\n`You` : Okay, let me think. and What about space ?\\n`Interviewer`: Space can be O(n) and if you can optimise the space as well then go ahead.\\n`You` : Ok, I think since we need to preserve order It would not be possible to done it in-place. So I will use one array of size n. Since I know if the element is even it\\'s position would be 0 for the first time and next time += 2 and so on.\\n\\nSo I will use two pointer for even and odd which will be at the position where I can insert even and odd element.\\n\\n`Interviewer` : Okay, write code for it.\\n`You` : Sure.\\n\\n*Le Keyboard: (TAPA, TAP, TAPA, TAP ... )\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n        for(int i = 0; i < n; ++i) {\\n            if(nums[i] >= 0) {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else {\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int pos = 0, neg = 1;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] >= 0) {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else {\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        pos, neg = 0, 1\\n        for i in range(n):\\n            if nums[i] >= 0:\\n                ans[pos] = nums[i]\\n                pos += 2\\n            else:\\n                ans[neg] = nums[i]\\n                neg += 2\\n        return ans\\n```\\n\\n```Note []\\nHere time complexity would be O(n) because in question we have been \\nasked to modify the input array itself. If we were asked not to modify\\nit we would be having our time complexity as O(1).\\n```\\n\\n`Interviewer` : We have some time left, I have one follow up question on this what if the order doesn\\'t matter , can you do that in-place ?\\n`You` : Ok, Let me think.\\n\\nAs we know that order doesn\\'t matter and also we have equal no. of positive and negatives.\\nSo what if positive is not at the correct index, we can get negative and swap it. same for the negative if it is not at correct index , we can get positive and swap.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/2b63530a-300a-40b6-b6db-e10edabfeffc_1707875931.6341405.png)\\n\\n`Interviewer` : Ok, what about time and space complexity here ?\\n`You`: As we are swapping the element in existing array itself, we don\\'t need any extra space so space complexity would be O(1).\\nand Time Complexity would be O(n) because we will traverse n elements once.\\n`Interviewer` : You can write code for this.\\n`You` : Sure !\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int pos = 0, neg = 1;\\n        while(pos < n && neg < n) {\\n            if(nums[pos] >= 0) pos += 2;\\n            else if(nums[neg] < 0) neg += 2;\\n            else {\\n                int temp = nums[pos];\\n                nums[pos] = nums[neg];\\n                nums[neg] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n`Interviewer` : I am done with my side, if you have any questions let me know.\\n`You` : No. ( FO )\\n\\n```Note []\\nThere is one more version to this question, where instead of \\npositive and negatives we have even and odd. So the concept \\nwould remain same just some condition will change.\\n```\\n\\nSome more follow up questions\\n```Similar-Questions []\\n1. What if no. of positive and negative are not equals \\n   and once one of the items finished, rest can be consecutives ?\\n\\n2. What if you have to return all positives together on \\n   left side and all negatives together in right side. \\n( This one I got in my interview, where I was asked to segreate \\neven and odd numbers. So I\\'ve done this using two pointer. )\\n\\n3. Segregate positive, negatives and zeros.\\n( This questions uses three pointer, one for positive , one for zero\\nand one for negative. )\\nThe above question is similar to the below question give it a try\\nhttps:\/\/leetcode.com\/problems\/partition-array-according-to-given-pivot\/\\n```\\n\\n\\nThanks All !!!\\nIf You have came this for, Don\\'t forget to upvote it !!!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"},
{"prompt":"<p>Given a set of <strong>distinct<\/strong> positive integers <code>nums<\/code>, return the largest subset <code>answer<\/code> such that every pair <code>(answer[i], answer[j])<\/code> of elements in this subset satisfies:<\/p>\n\n<ul>\n\t<li><code>answer[i] % answer[j] == 0<\/code>, or<\/li>\n\t<li><code>answer[j] % answer[i] == 0<\/code><\/li>\n<\/ul>\n\n<p>If there are multiple solutions, return any of them.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [1,2,3]\n<strong>Output:<\/strong> [1,2]\n<strong>Explanation:<\/strong> [1,3] is also accepted.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [1,2,4,8]\n<strong>Output:<\/strong> [1,2,4,8]\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000<\/code><\/li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>9<\/sup><\/code><\/li>\n\t<li>All the integers in <code>nums<\/code> are <strong>unique<\/strong>.<\/li>\n<\/ul>\n\n\n###\n\n","completion":" \\n```\\uD83D\\uDCA1Warning []\\nIf you know LIS ( Longest Increasing Subsequence ), \\nplease don\\'t watch this blog just try to think how can you map that\\nlogic here. Although in this blog It\\'s first and last time I\\'m\\nmentioning LIS.\\n```\\n\\n### Youtube Solution ( In Hindi Language Only )\\nhttps:\/\/www.youtube.com\/watch?v=0EAv6OKEZSk&ab_channel=CSIITIAN\\n\\n## Common Sense\\nIn Each group atleast one element would be present, so for size 1 we can have n no. of groups.\\n\\nNow let\\'s make some sense, how would you add a number in the group\\nGroup: [1, 3, 6]\\nand you have 9, would you be able to add ?\\nOf Course not why because 9 would not be divisble by 6.\\n\\nWhat about 12 ? Yes you can add 12.\\n\\n## Observation to Add New Number\\nNow one more thing to observe here is If I just divide the newly (to be) added number by the maximum element of my group I can make sure the whole group is divided. ( Because the group\\'s LCM is the maximum number )\\n\\n### Can I add number less than the maximum number in group ?\\nWell yes ! Let\\'s see\\nGroup: [1, 4, 8]\\nand now can I add 2 here ? yes ! Now new Group would be [1, 2, 4, 8]\\n\\nSo I have to handle two things, \\n1. If the number is greater or equal to maximum of group, then it should be divisible by maximum.\\n2. If the number is less than maximum of group, it should divide all the group members.\\n\\nWe can see that in first point, It is much easy to add I just need to know maximum but in second point I need to traverse the whole group to be able to add new element.\\n\\n## What If Say, I Can handle both in First Point itself\\nPreviously we have seen two points by which we can add new number to a group.\\nBut What if I always make sure that I add new number using first point only. I mean what if I always make sure that the number I am adding is always greater than group ?\\n\\nTake a Pause and Think about it , How can we do it ?\\n\\nOkay, so basically I will sort the array to make sure the element which I am going to add is always greater.\\n\\nNow I don\\'t need to know the group.\\n\\nSo for current element, I can check all the previous and check divisibility and if it is divisble then it can be added to group so I will increase the group size by 1.\\n\\nNow I know the size, but here I also need to know the group element, So I also keep track of the element. So whenever I increase the group size I will add the previous element. So that I can backtrack the origin of the group. ( Group\\'s starting point would be marked as -1 )\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the Array ( ascending order )\\n2. For Each Element traverse the previous element\\n3. If element is divisible by any previous element it means it can be part of that group by we also need to make sure it is part of the group with maximum size, So if we found any bigger group we will add it to that group\\n4. If we update the group size, it means we have added new element I will update my previous of the current element with group\\'s maximum till now ( before adding )\\n5. I will also track the index of the last element added in the biggest group\\n6. Now I will backtraverse from that maximum index ( defined in previous point ) using my previous element array and one by one add into my result list\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public List<Integer> largestDivisibleSubset(int[] nums) {\\n       \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n       \\n        int[] groupSize = new int[n];\\n        int[] prevElement = new int[n];\\n        int maxIndex = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            groupSize[i] = 1;\\n            prevElement[i] = -1;\\n            for(int j=0;j<i;j++) {\\n                if(nums[i]%nums[j] == 0) {\\n                    if(groupSize[i] < 1 + groupSize[j]) {\\n                        groupSize[i] = 1 + groupSize[j];\\n                        prevElement[i] = j;\\n                    }\\n                }\\n            }\\n            if(groupSize[i] > groupSize[maxIndex]) {\\n                maxIndex = i;\\n            }\\n        }\\n\\n        List<Integer> result = new ArrayList();\\n        while(maxIndex != -1) {\\n            result.add(0, nums[maxIndex]);\\n            maxIndex = prevElement[maxIndex];\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> largestDivisibleSubset(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        vector<int> groupSize(n, 1), prevElement(n, -1);\\n        int maxIndex = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (nums[i] % nums[j] == 0 && groupSize[i] < groupSize[j] + 1) {\\n                    groupSize[i] = groupSize[j] + 1;\\n                    prevElement[i] = j;\\n                }\\n            }\\n            if (groupSize[i] > groupSize[maxIndex]) {\\n                maxIndex = i;\\n            }\\n        }\\n\\n        vector<int> result;\\n        for (int i = maxIndex; i != -1; i = prevElement[i]) {\\n            result.insert(result.begin(), nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Kotlin []\\nfun largestDivisibleSubset(nums: IntArray): List<Int> {\\n    nums.sort()\\n    val n = nums.size\\n    val groupSize = IntArray(n) { 1 }\\n    val prevElement = IntArray(n) { -1 }\\n    var maxIndex = 0\\n\\n    for (i in nums.indices) {\\n        for (j in 0 until i) {\\n            if (nums[i] % nums[j] == 0 && groupSize[i] < groupSize[j] + 1) {\\n                groupSize[i] = groupSize[j] + 1\\n                prevElement[i] = j\\n            }\\n        }\\n        if (groupSize[i] > groupSize[maxIndex]) {\\n            maxIndex = i\\n        }\\n    }\\n\\n    val result = mutableListOf<Int>()\\n    var i = maxIndex\\n    while (i != -1) {\\n        result.add(0, nums[i])\\n        i = prevElement[i]\\n    }\\n    return result\\n}\\n```\\n```Python []\\nclass Solution:\\n    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        n = len(nums)\\n        groupSize = [1] * n\\n        prevElement = [-1] * n\\n        maxIndex = 0\\n\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[i] % nums[j] == 0:\\n                    if groupSize[i] < 1 + groupSize[j]:\\n                        groupSize[i] = 1 + groupSize[j]\\n                        prevElement[i] = j\\n            if groupSize[i] > groupSize[maxIndex]:\\n                maxIndex = i\\n\\n        result = []\\n        while maxIndex != -1:\\n            result.insert(0, nums[maxIndex])\\n            maxIndex = prevElement[maxIndex]\\n\\n        return result\\n```\\n```JavaScript []\\n\/**\\n * @param {number[]} nums\\n * @return {number[]}\\n *\/\\nvar largestDivisibleSubset = function(nums) {\\n    nums.sort((a, b) => a - b);\\n    const n = nums.length;\\n    const groupSize = new Array(n).fill(1);\\n    const prevElement = new Array(n).fill(-1);\\n    let maxIndex = 0;\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (nums[i] % nums[j] === 0 && groupSize[i] < groupSize[j] + 1) {\\n                groupSize[i] = groupSize[j] + 1;\\n                prevElement[i] = j;\\n            }\\n        }\\n        if (groupSize[i] > groupSize[maxIndex]) {\\n            maxIndex = i;\\n        }\\n    }\\n\\n    const result = [];\\n    for (let i = maxIndex; i !== -1; i = prevElement[i]) {\\n        result.unshift(nums[i]);\\n    }\\n\\n    return result;\\n};\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn largest_divisible_subset(nums: Vec<i32>) -> Vec<i32> {\\n        let mut nums = nums;\\n        nums.sort();\\n        let n = nums.len();\\n        let mut group_size = vec![1; n];\\n        let mut prev_element = vec![-1; n];\\n        let mut max_index = 0;\\n\\n        for i in 0..n {\\n            for j in 0..i {\\n                if nums[i] % nums[j] == 0 && group_size[i] < group_size[j] + 1 {\\n                    group_size[i] = group_size[j] + 1;\\n                    prev_element[i] = j as i32;\\n                }\\n            }\\n            if group_size[i] > group_size[max_index] {\\n                max_index = i;\\n            }\\n        }\\n\\n        let mut result = Vec::new();\\n        let mut i = max_index as i32;\\n        while i != -1 {\\n            result.insert(0, nums[i as usize]);\\n            i = prev_element[i as usize];\\n        }\\n        result\\n    }\\n}\\n```\\n```Go []\\nfunc largestDivisibleSubset(nums []int) []int {\\n    sort.Ints(nums)\\n    n := len(nums)\\n    groupSize := make([]int, n)\\n    prevElement := make([]int, n)\\n    maxIndex := 0\\n\\n    for i := 0; i < n; i++ {\\n        groupSize[i] = 1\\n        prevElement[i] = -1\\n        for j := 0; j < i; j++ {\\n            if nums[i]%nums[j] == 0 && groupSize[j]+1 > groupSize[i] {\\n                groupSize[i] = groupSize[j] + 1\\n                prevElement[i] = j\\n            }\\n        }\\n        if groupSize[i] > groupSize[maxIndex] {\\n            maxIndex = i\\n        }\\n    }\\n\\n    var result []int\\n    for i := maxIndex; i != -1; i = prevElement[i] {\\n        result = append([]int{nums[i]}, result...)\\n    }\\n    return result\\n}\\n```\\n\\nThat\\'s it guys !!!\\n\\n## If you really come this far, please upvoted it !\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"},
{"prompt":"<p>Given an array <code>nums<\/code> of size <code>n<\/code>, return <em>the majority element<\/em>.<\/p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n \/ 2&rfloor;<\/code> times. You may assume that the majority element always exists in the array.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<pre><strong>Input:<\/strong> nums = [3,2,3]\n<strong>Output:<\/strong> 3\n<\/pre><p><strong class=\"example\">Example 2:<\/strong><\/p>\n<pre><strong>Input:<\/strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:<\/strong> 2\n<\/pre>\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>n == nums.length<\/code><\/li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4<\/sup><\/code><\/li>\n\t<li><code>-10<sup>9<\/sup> &lt;= nums[i] &lt;= 10<sup>9<\/sup><\/code><\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<strong>Follow-up:<\/strong> Could you solve the problem in linear time and in <code>O(1)<\/code> space?\n\n###\n\n","completion":" Hi All, I hope you are doing great !\\n\\n```Note []\\nBefore moving into interview, I\\'ve something for you !!! \\n\\nWhen I was in 9th class, my teacher ask us a question, He drew 2 lines\\non board first one was longer and second one was shorter and ask us how\\nthe second line can be longer than first one.\\n\\nSome students said we can erase the first line a little bit to make \\nit shorter than the second one. and some said it is impossible.\\nLater on teacher expanded the shorter one to make it longer.\\n\\nI\\'ve learned one thing from that day that\\n- In your life if you want to grow, work hard. Don\\'t defame others.\\n```\\n\\n## Video Solution ( in Hindi Language )\\nhttps:\/\/youtu.be\/m3FFBjb--cs\\n\\nIf this has been asked in interview first thing would be simple solution that comes out of your mind easily.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/a69d3006-c1b0-41bc-98aa-383009ff2dcc_1707701880.8592477.png)\\n\\n\\n\\nBrute Force Solution: For each element we will check the count in array and if it is more than n\/2 we will return our result.\\n\\n( Note: Interviewer might not want you to code this approach )\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) {\\n            int count = 1;\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count > n\/2) return nums[i];\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n`Interviewer` : What would be time and space complexity ?\\n`You` : Time Complexity would be O(n^2) because we have two for loops. and Space Complexity would be O(1).\\n\\n`Interviewer` : Can you further optimise it ?\\n\\n```Tip#1 []\\nIf this is the first question interviewer ask you can drag the \\ninterview. Also keep in mind the time if you spend so much time \\nhere other problems might be hard and might require more time. \\nSo Be aware of that.\\n```\\n\\n`You` : Yes, I think we can sort the array, as we know the frequency should be more than \\u230An \/ 2\\u230B. Our middle element will be our answer.\\n\\n`Interviewer` : How you so sure about this ?\\n\\n`You` : ( Because I have proof ) Ok, so when we sort array all same element would be at same place. Now length more than \\u230An \/ 2\\u230B will always cross the middle element, even if it starts from the first index or it ends at the last index.\\n\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length \/ 2];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums) \/\/ 2]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size() \/ 2];\\n    }\\n};\\n```\\n\\n`Interviewer` : Here what would be your time and space complexity ?\\n\\n`You` : Time Complexity would be O(n*logn) due to sorting and Space Complexity would be O(1).\\n\\n\\n`Interviewer` : Think of something that can be done in O(n) time.\\n\\n`You` : Yes, I think we can use map here. We will store each number\\'s frequency and whichever number will have frequency more than \\u230An \/ 2\\u230B will be our answer.\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freqCount = new HashMap();\\n        for(int num: nums) {\\n            freqCount.put(num, freqCount.getOrDefault(num, 0) + 1);\\n        }\\n        for(Map.Entry<Integer, Integer> entry: freqCount.entrySet()) {\\n            if(entry.getValue() > n\/2) return entry.getKey();\\n        }\\n        return -1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        freq_count = {}\\n        n = len(nums)\\n        for num in nums:\\n            freq_count[num] = freq_count.get(num, 0) + 1\\n        for num, count in freq_count.items():\\n            if count > n \/\/ 2:\\n                return num\\n        return -1\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> freqCount;\\n        int n = nums.size();\\n        for(int num : nums) {\\n            ++freqCount[num];\\n        }\\n        for(auto& entry : freqCount) {\\n            if(entry.second > n \/ 2) return entry.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n`Interviewer` : What would be time and space complexity here ?\\n\\n`You` : Time Complexity would be O(n) iterating through each array two times and Space Complexity would be O(n) for storing frequencies.\\n\\n`Interviewer` : Can you think of something with O(1) space ?\\n\\n```Tip#2 []\\nHere if you already know the Boyer Moore Voting Algorithm, \\nyou can directly say you will use this algorithm. \\nBe honest in your interview.\\nIf you know something it means that you are well prepared for this\\ninterview and you are honest It is sign of good programmers.\\n```\\n\\n`You` : Hmm ! Let me think !\\n`Interviewer` : ( Giving Hint ) Don\\'t you agree that the answer would always be more than the total count of other number.\\n`You` : Yes ! I agree. ( MF, I know that f**king algorithm you are heading towards )\\n`Interviewer` : Ok, what if every one number will cancel other distinct number, the number left at the end would be our answer.\\n`You` : Yeah, I got it. If I can pick first number as my answer then going forward I can increment the count if we have similar number and decrement if we have distinct number, if at any time I have count 0, I will assign my current number as answer and will proceed further.\\n`Interviewer` : Yes, Correct !\\n`You` : \\nLet\\'s see through test cases\\n[1, 1, 2]\\nNow let\\'s say our answer is 1, for\\nindex 0 -> count - 1\\nindex 1 -> count - 2\\nindex 2 -> count 1\\nso for 1 our count is 1 and 1 would be our answer.\\n\\nlet\\'s see one more test cases\\n[1, 2, 1]\\nindex 0 -> count - 1\\nindex 1 -> count - 0\\nnow change our answer to 2 and count - 1\\nindex 2 -> count - 0\\nnow change our answer to 1 and count - 1\\nSo our final answer here would be 1.\\n\\n`Interviewer` : JFYI, It is called `Boyer-Moore Majority Vote Algorithm`.\\n\\n```Note\\nIf you guys already know this algorithm you can directly tell \\nthe interviewer about this.\\n```\\n\\n`Interviewer` : Let\\'s write code for this.\\n`You` : Le keyboard ( TAPA TAP TAPA TAP .... )\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 1;\\n        int ans = nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] != ans) {\\n                count--;\\n            } else {\\n                count++;\\n            }\\n            if(count == 0) {\\n                ans = nums[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count = 1\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] != ans:\\n                count -= 1\\n            else:\\n                count += 1\\n            \\n            if count == 0:\\n                ans = nums[i]\\n                count = 1\\n        \\n        return ans\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 1;\\n        int ans = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != ans) {\\n                count--;\\n            } else {\\n                count++;\\n            }\\n            if(count == 0) {\\n                ans = nums[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`Interviewer` : Good, What about Time and Space Complexity ?\\n\\n`You` : Time Complexity would be O(n) we have done in one traversal and Space Complexity would be O(1).\\n\\n`Interviewer` : Tell me one thing, have you seen this problem earlier ?\\n\\n`You` : Yes ( MF, you are not the one who invented this ) , But I was not aware of that algorithm. ( If you know tell ***honestly*** this is for those  who don\\'t know and came up with approach with some hints from interviewer .)\\n\\n`Interviewer` : Let\\'s move to the next problem.\\n\\nThat\\'s it guys, I hope you really enjoyed reading this blog. If yes let me know in comment section.\\nIf you have any doubts let me know , I am not an expert but I will try my best to answer.\\n\\nThank you !!! Bye Bye !!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"},
{"prompt":"<p>Given an integer <code>n<\/code>, return <em>the least number of perfect square numbers that sum to<\/em> <code>n<\/code>.<\/p>\n\n<p>A <strong>perfect square<\/strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1<\/code>, <code>4<\/code>, <code>9<\/code>, and <code>16<\/code> are perfect squares while <code>3<\/code> and <code>11<\/code> are not.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> n = 12\n<strong>Output:<\/strong> 3\n<strong>Explanation:<\/strong> 12 = 4 + 4 + 4.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> n = 13\n<strong>Output:<\/strong> 2\n<strong>Explanation:<\/strong> 13 = 4 + 9.\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4<\/sup><\/code><\/li>\n<\/ul>\n\n\n###\n\n","completion":" ## Youtube Video Solution ( in Hindi )\\nhttps:\/\/www.youtube.com\/watch?v=hGYemyJ8ePc&ab_channel=CSIITIAN\\n\\n**Edit:** *as [iempriyanshu2](https:\/\/leetcode.com\/iempriyanshu2\/) suggests, we will never reach negative because we are making sure we always perform operation for less than or equal to n. So going forward in this blog you can ignore the negative condition.* - Thanks [iempriyanshu2](https:\/\/leetcode.com\/iempriyanshu2\/)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we go greedy like for 12, picking up the maximum closest square it would fail in our first test case\\n```\\n12 -> 9 + 1 + 1 + 1 ( Greedy Solution Failed )\\n12 -> 4 + 4 + 4 ( Actual Answer )\\n```\\n\\nSo we will iterate through all possible squares and will try to minimise the count.\\n\\n```\\n\/\/ Base Case\\n1. n == 0 ( answer = 0 )\\n2. n < 0 ( answer = INT_MAX , because it can\\'t go negative since\\nwe are picking up minimum we need to make this INT_MAX \\nso that it can not be part of our calculations )\\n```\\n\\n### Formula\\n```\\nfun(n) = perfect_square + fun(n - perfect_square)\\nso perfect_square can be from 1 to n\\n\\nSo basically we will iterate till perfect_square ( j*j <= n ), \\nwhere j*j is perfect_square\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1 -> 1 + fun(0) -> 1\\n2 -> 1 + fun(1) -> 2 ( fun(1) already calculated )\\n3 -> 1 + fun(2) -> 3 ( fun(2) already calculated )\\n4 -> min(1 + fun(3), 4 + fun(0)) -> min(4, 1) -> 1\\n```\\n\\nSo in above example you can see for fun(4), when our perfect_square is 1, our answer is 4 and if we pick our next perfect_square then answer is 1, because 4 is itself a perfect square. So we will pick minimum among them and our final answer would be 1.\\n\\n## Let\\'s Code ( Bottom Up Approach )\\n```java []\\nclass Solution {\\n    public int numSquares(int n) {\\n        return solve(n);\\n    }\\n\\n    public int solve(int n) {\\n        if(n == 0) return 0;\\n        if(n < 0) return Integer.MAX_VALUE;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1;i*i<=n;i++) {\\n            ans = Math.min(\\n                ans,\\n                1 + solve(n-(i*i))\\n            );\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nI\\'m excited to submit this,  are you ? Let\\'s submit.\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/faa67471-112d-4fea-9d43-29eb29c4c3fe_1707353513.0228646.png)\\n\\n\\nWhat the f**k ? It got TLE. Every programmer hate the `RED` color.\\n\\nNow let\\'s optimise it.\\n\\nSo in the approach section, I\\'ve mentioned for fun(2) we are using fun(1) and that we have already calculated, so no need to calculate it again. So\\nwhat I will do is I will store the answer for that intermediate state and will use if I need further.\\n\\nSo Let\\'s Optimise the code\\n\\n```java []\\nclass Solution {\\n\\n    int[] memo;\\n\\n    public int numSquares(int n) {\\n        memo = new int[n+1];\\n        Arrays.fill(memo, -1);\\n        return solve(n);\\n    }\\n\\n    public int solve(int n) {\\n        if(n == 0) return 0;\\n        if(n < 0) return Integer.MAX_VALUE;\\n        if(memo[n] != -1) return memo[n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1;i*i<=n;i++) {\\n            ans = Math.min(\\n                ans,\\n                1 + solve(n-(i*i))\\n            );\\n        }\\n        return memo[n] = ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        memo = [-1] * (n + 1)\\n        \\n        def solve(n):\\n            if n == 0:\\n                return 0\\n            if n < 0:\\n                return float(\\'inf\\')\\n            if memo[n] != -1:\\n                return memo[n]\\n            ans = float(\\'inf\\')\\n            i = 1\\n            while i * i <= n:\\n                ans = min(ans, 1 + solve(n - i * i))\\n                i += 1\\n            memo[n] = ans\\n            return ans\\n        \\n        return solve(n)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    std::vector<int> memo;\\n\\n    int numSquares(int n) {\\n        memo.resize(n + 1, -1);\\n        return solve(n);\\n    }\\n\\n    int solve(int n) {\\n        if (n == 0) return 0;\\n        if (n < 0) return INT_MAX;\\n        if (memo[n] != -1) return memo[n];\\n        int ans = INT_MAX;\\n        for (int i = 1; i * i <= n; ++i) {\\n            ans = std::min(ans, 1 + solve(n - i * i));\\n        }\\n        return memo[n] = ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n^3\/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nNow every recursive problem can be converted into iterative solution, specially the problem that are overlapping ( means we are storing the intermediate state )\\n\\nSo let\\'s convert this into Iterative Approach\\n```Note []\\nIn Java code I have commented to understand better \\nhow we have converted into iterative solution.\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n+1];\\n        Arrays.fill(memo, Integer.MAX_VALUE); \/\/ because we are picking up minimum\\n        memo[0] = 0; \/\/ base condition\\n        \\n        for(int i=1;i<=n;i++) { \/\/ recursive function\\n            for(int j=1;j*j<=i;j++) { \/\/ loop in function\\n                memo[i] = Math.min(memo[i], 1 + memo[i-(j*j)]); \/\/ returning result\\n            }\\n        }\\n\\n        return memo[n];\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        memo = [float(\\'inf\\')] * (n + 1)\\n        memo[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            j = 1\\n            while j * j <= i:\\n                memo[i] = min(memo[i], 1 + memo[i - j * j])\\n                j += 1\\n                \\n        return memo[n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        std::vector<int> memo(n + 1, INT_MAX);\\n        memo[0] = 0;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j*j <= i; ++j) {\\n                memo[i] = std::min(memo[i], 1 + memo[i - j*j]);\\n            }\\n        }\\n        \\n        return memo[n];\\n    }\\n};\\n```\\n\\nThat\\'s all guys !!!\\n\\nI would say if you understand this problem, there are many problems related to this.\\nYou can do all, I bet !\\n\\nThank you guys !!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"},
{"prompt":"<p>You are given a <strong>0-indexed<\/strong> 2D matrix <code>grid<\/code> of size <code>n x n<\/code>, where <code>(r, c)<\/code> represents:<\/p>\n\n<ul>\n\t<li>A cell containing a thief if <code>grid[r][c] = 1<\/code><\/li>\n\t<li>An empty cell if <code>grid[r][c] = 0<\/code><\/li>\n<\/ul>\n\n<p>You are initially positioned at cell <code>(0, 0)<\/code>. In one move, you can move to any adjacent cell in the grid, including cells containing thieves.<\/p>\n\n<p>The <strong>safeness factor<\/strong> of a path on the grid is defined as the <strong>minimum<\/strong> manhattan distance from any cell in the path to any thief in the grid.<\/p>\n\n<p>Return <em>the <strong>maximum safeness factor<\/strong> of all paths leading to cell <\/em><code>(n - 1, n - 1)<\/code><em>.<\/em><\/p>\n\n<p>An <strong>adjacent<\/strong> cell of cell <code>(r, c)<\/code>, is one of the cells <code>(r, c + 1)<\/code>, <code>(r, c - 1)<\/code>, <code>(r + 1, c)<\/code> and <code>(r - 1, c)<\/code> if it exists.<\/p>\n\n<p>The <strong>Manhattan distance<\/strong> between two cells <code>(a, b)<\/code> and <code>(x, y)<\/code> is equal to <code>|a - x| + |b - y|<\/code>, where <code>|val|<\/code> denotes the absolute value of val.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2023\/07\/02\/example1.png\" style=\"width: 362px; height: 242px;\" \/>\n<pre>\n<strong>Input:<\/strong> grid = [[1,0,0],[0,0,0],[0,0,1]]\n<strong>Output:<\/strong> 0\n<strong>Explanation:<\/strong> All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2023\/07\/02\/example2.png\" style=\"width: 362px; height: 242px;\" \/>\n<pre>\n<strong>Input:<\/strong> grid = [[0,0,1],[0,0,0],[0,0,0]]\n<strong>Output:<\/strong> 2\n<strong>Explanation:<\/strong> The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2023\/07\/02\/example3.png\" style=\"width: 362px; height: 242px;\" \/>\n<pre>\n<strong>Input:<\/strong> grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]\n<strong>Output:<\/strong> 2\n<strong>Explanation:<\/strong> The path depicted in the picture above has a safeness factor of 2 since:\n- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.\n- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.\nIt can be shown that there are no other paths with a higher safeness factor.\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= grid.length == n &lt;= 400<\/code><\/li>\n\t<li><code>grid[i].length == n<\/code><\/li>\n\t<li><code>grid[i][j]<\/code> is either <code>0<\/code> or <code>1<\/code>.<\/li>\n\t<li>There is at least one thief in the <code>grid<\/code>.<\/li>\n<\/ul>\n\n\n###\n\n","completion":" ## Subscribe to our Channel\\nhttps:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw ( Target 1K )\\n\\n## Chat GPT for DSA Interview Format\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/a2b35c64-2a1d-49b9-a03a-69e55a78ed25_1715782560.9524956.png)\\n\\n\\n### Interviewer and Interviewee Discussion\\n\\n**Interviewer:** Let\\'s discuss a problem involving paths and safeness factors. Given a 2D matrix grid of size \\\\( n x n \\\\), each cell either contains a thief (represented by 1) or is an empty cell (represented by 0). You start at cell (0, 0) and can move to any adjacent cell. The safeness factor of a path is the minimum Manhattan distance from any cell in the path to any thief in the grid. You need to return the maximum safeness factor of all paths leading to the bottom-right cell (n-1, n-1). \\n\\n**Interviewee:** Understood. To summarize, we need to find the safest path from the top-left to the bottom-right of the grid, where the safeness factor is defined as the shortest Manhattan distance to the nearest thief on that path, and we aim to maximize this minimum distance.\\n\\n**Interviewer:** Correct. Can you state your initial thoughts?\\n\\n### Initial Thoughts and Brute Force Approach\\n\\n**Interviewee:** For a brute force approach, I would consider all possible paths from (0, 0) to (n-1, n-1). For each path, we would calculate the minimum Manhattan distance to any thief and keep track of the maximum of these minimum distances. \\n\\nHowever, this would involve an exhaustive search of all possible paths, which is not feasible due to the exponential number of possible paths in the grid.\\n\\n**Interviewer:** Yes, the brute force approach would indeed be infeasible for large grids due to the combinatorial explosion. Let\\'s consider more efficient ways to solve the problem, both in terms of time and space complexity.\\n\\n### Time and Space Complexity of Brute Force\\n\\n**Interviewee:** The time complexity for the brute force approach would be O(2^(n*n)), given that each cell can lead to many different paths. The space complexity would be O(n*n) to store the grid and paths.\\n\\n**Interviewer:** Great. Let\\'s move to a more optimized solution. Can you think of any data structures or algorithms that could help improve efficiency?\\n\\n### Optimized Approach Using BFS and Distance Calculations\\n\\n**Interviewee:** A more efficient approach would be using Breadth-First Search (BFS) to find the minimum distances from each cell to the nearest thief. We can start by identifying all the thieves\\' positions in the grid and perform a multi-source BFS to propagate the distances.\\n\\n**Interviewer:** That sounds promising. Can you explain how this works in detail?\\n\\n**Interviewee:** Sure:\\n\\n1. **Multi-source BFS for Distance Calculation:**\\n    - Initialize a distance grid `dist` of size \\\\( n \\\\times n \\\\) with infinity.\\n    - Collect all thief positions and initialize their distances to 0.\\n    - Run BFS from all these thief positions to calculate the minimum distance to any thief for all cells.\\n\\n2. **Find the Maximum Safeness Path:**\\n    - Use a priority queue (max-heap) to explore paths, prioritizing paths with higher safeness factors.\\n    - Start from the top-left corner, keep track of the maximum safeness factor on any path to each cell, and expand to adjacent cells.\\n    - Continue until reaching the bottom-right corner, and update the maximum safeness factor of any valid path found.\\n\\nOverall, the BFS for distance calculation runs in O(n^2) time, and finding the safeness path using a priority queue also runs in O(n^2 * log(n)).\\n\\n### Drawing and Explanation\\n\\n**Interviewer:** Let\\'s visualize this approach. Can you draw an example of how it works?\\n\\n**Interviewee:** Sure. Here\\'s a step-by-step representation:\\n\\n1. **Grid Initialization and Multi-source BFS:**\\n    ```\\n    Initial grid:\\n    1 0 0\\n    0 0 0\\n    0 0 1\\n    ```\\n\\n2. **Distance Calculation (Multi-source BFS):**\\n    ```\\n    Distance grid after BFS:\\n    0 1 2\\n    1 2 1\\n    2 1 0\\n    ```\\n\\n3. **Safeness Path Calculation:**\\n    - Start at (0,0) with safeness factor 0. Push (0,0,0) into max-heap.\\n    - Expand to adjacent cells, always choosing maximum safeness paths.\\n    - Final path with maximum safeness factor:\\n    ```\\n    Maximum safeness path:\\n    0 1 2\\n    1 2 1\\n    x x 0  (path marked with x\\'s)\\n    ```\\n\\nThe safest path strategy in this example would move along the boundaries to avoid close contact with thieves, maximizing the minimum distance to a thief.\\n\\n**Interviewer:** Excellent explanation and visualization! This approach is efficient and well-thought-out. Great job!Sure! Let\\'s write the optimized solution in C++, Java, and Python. We\\'ll follow the described approach: first calculating the minimum distances from any cell to the nearest thief using multi-source BFS, then determining the maximum safeness factor using a priority queue for path exploration.\\n\\n### C++ Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    int maximumSafenessFactor(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n\\n        \/\/ Initialize all thief positions\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                if (grid[r][c] == 1) {\\n                    q.push({r, c});\\n                    dist[r][c] = 0;\\n                }\\n            }\\n        }\\n\\n        \/\/ Multi-source BFS to calculate minimum distance to any thief\\n        while (!q.empty()) {\\n            auto [r, c] = q.front();\\n            q.pop();\\n            for (auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n && dist[nr][nc] == INT_MAX) {\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                    q.push({nr, nc});\\n                }\\n            }\\n        }\\n\\n        \/\/ Use priority queue to find path with maximum safeness factor\\n        priority_queue<pair<int, pair<int, int>>> pq;\\n        pq.push({dist[0][0], {0, 0}});\\n        vector<vector<int>> maxSafeness(n, vector<int>(n, -1));\\n        maxSafeness[0][0] = dist[0][0];\\n\\n        while (!pq.empty()) {\\n            auto [d, pos] = pq.top();\\n            pq.pop();\\n            int r = pos.first, c = pos.second;\\n            if (r == n - 1 && c == n - 1) return d;  \/\/ Reached bottom-right corner\\n\\n            for (auto& dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\\n                    int newSafe = min(d, dist[nr][nc]);\\n                    if (newSafe > maxSafeness[nr][nc]) {\\n                        maxSafeness[nr][nc] = newSafe;\\n                        pq.push({newSafe, {nr, nc}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;  \/\/ In case there\\'s no valid path\\n    }\\n};\\n```\\n\\n### Java Code\\n\\n```java\\nclass Solution {\\n\\n    static int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\\n        int n = grid.size();\\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) Arrays.fill(row, Integer.MAX_VALUE);\\n        Queue<int[]> q = new LinkedList<>();\\n\\n        \/\/ Initialize all thief positions\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid.get(r).get(c) == 1) {\\n                    q.offer(new int[]{r, c});\\n                    dist[r][c] = 0;\\n                }\\n            }\\n        }\\n\\n        \/\/ Multi-source BFS to calculate minimum distance to any thief\\n        while (!q.isEmpty()) {\\n            int[] cell = q.poll();\\n            int r = cell[0], c = cell[1];\\n            for (int[] dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n && dist[nr][nc] == Integer.MAX_VALUE) {\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                    q.offer(new int[]{nr, nc});\\n                }\\n            }\\n        }\\n\\n        \/\/ Use priority queue to find path with maximum safeness factor\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        pq.offer(new int[]{dist[0][0], 0, 0});\\n        int[][] maxSafeness = new int[n][n];\\n        for (int[] row : maxSafeness) Arrays.fill(row, -1);\\n        maxSafeness[0][0] = dist[0][0];\\n\\n        while (!pq.isEmpty()) {\\n            int[] cell = pq.poll();\\n            int d = cell[0], r = cell[1], c = cell[2];\\n            if (r == n - 1 && c == n - 1) return d;\\n\\n            for (int[] dir : directions) {\\n                int nr = r + dir[0], nc = c + dir[1];\\n                if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\\n                    int newSafe = Math.min(d, dist[nr][nc]);\\n                    if (newSafe > maxSafeness[nr][nc]) {\\n                        maxSafeness[nr][nc] = newSafe;\\n                        pq.offer(new int[]{newSafe, nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;  \/\/ In case there\\'s no valid path        \\n    }\\n}\\n```\\n\\n### Python Code\\n\\n```python\\nclass Solution:\\n    def maximumSafenessFactor(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        dist = [[float(\\'inf\\')] * n for _ in range(n)]\\n        q = deque()\\n\\n        # Initialize all thief positions\\n        for r in range(n):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    q.append((r, c))\\n                    dist[r][c] = 0\\n\\n        # Multi-source BFS to calculate minimum distance to any thief\\n        while q:\\n            r, c = q.popleft()\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < n and 0 <= nc < n and dist[nr][nc] == float(\\'inf\\'):\\n                    dist[nr][nc] = dist[r][c] + 1\\n                    q.append((nr, nc))\\n\\n        # Use priority queue to find path with maximum safeness factor\\n        max_heap = [(-dist[0][0], 0, 0)]\\n        max_safeness = [[-1] * n for _ in range(n)]\\n        max_safeness[0][0] = dist[0][0]\\n\\n        while max_heap:\\n            d, r, c = heapq.heappop(max_heap)\\n            d = -d\\n            if r == n - 1 and c == n - 1:\\n                return d  # Reached bottom-right corner\\n\\n            for dr, dc in directions:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < n and 0 <= nc < n:\\n                    new_safe = min(d, dist[nr][nc])\\n                    if new_safe > max_safeness[nr][nc]:\\n                        max_safeness[nr][nc] = new_safe\\n                        heapq.heappush(max_heap, (-new_safe, nr, nc))\\n\\n        return -1  # In case there\\'s no valid path\\n```\\n\\n### Complexity Analysis\\n\\n- **Time Complexity:**\\n  - **BFS:** O(n^2) for computing distances since each cell and its neighbors are processed once.\\n  - **Path Finding Using Priority Queue:** O(n^2 * log(n)) as each cell is pushed and popped from the heap, and each operation is logarithmic in time complexity.\\n\\n- **Space Complexity:**\\n  - **BFS:** O(n^2) to store the distances and queue for processing cells.\\n  - **Priority Queue:** O(n^2) to manage the cells being processed, and the duplicate queue for distances.\\n\\nThese complexities are efficient and acceptable for the given problem constraints (1 <= grid.length <= 400).\\n\\n### Closing Statement\\n\\nIn this discussion, we tackled a challenging problem that involves finding the safest path in a grid from the top-left to the bottom-right cell, avoiding thieves as much as possible. We started by considering a brute force approach, but quickly realized its infeasibility due to the exponential complexity. We then optimized the solution significantly using a combination of multi-source BFS for distance calculation and a priority queue to explore paths with the maximum safeness factor efficiently.\\n\\nBy implementing this approach in C++, Java, and Python, we ensured that the solution is not only optimized but also adaptable across different programming languages. The time complexity of O(n^2 * log(n)) and space complexity of O(n^2) are well-suited for the problem constraints.\\n\\n### Similar Questions\\n\\nHere are some related problems that involve paths, grids, and dynamic programming techniques:\\n\\n1. **LeetCode 64: Minimum Path Sum**\\n   - Given a `m x n` grid filled with non-negative numbers, find a path from the top-left to the bottom-right that minimizes the sum of all numbers along its path.\\n\\n2. **LeetCode 174: Dungeon Game**\\n   - The knight has to reach the bottom-right cell from the top-left cell in a dungeon grid while maintaining his health points. Determine the knight\\'s minimum starting health.\\n\\n3. **LeetCode 1293: Shortest Path in a Grid with Obstacles Elimination**\\n   - Given a grid with obstacles, find the shortest path from the top-left corner to the bottom-right corner, with the ability to eliminate a limited number of obstacles.\\n\\n4. **LeetCode 542: 01 Matrix**\\n   - Given a matrix consisting of 0s and 1s, find the distance of the nearest 0 for each cell. Use multi-source BFS to solve the problem efficiently.\\n\\n5. **LeetCode 1182: Shortest Distance to Target Color**\\n   - In a list of colors, answer multiple queries about the shortest distance to a given color from any position.\\n\\nThese problems help reinforce the concepts of dynamic programming, BFS, priority queues, and grid traversal, which are crucial for solving complex pathfinding and optimization tasks efficiently.\n"},
{"prompt":"<p>You are given the head of a singly linked-list. The list can be represented as:<\/p>\n\n<pre>\nL<sub>0<\/sub> &rarr; L<sub>1<\/sub> &rarr; &hellip; &rarr; L<sub>n - 1<\/sub> &rarr; L<sub>n<\/sub>\n<\/pre>\n\n<p><em>Reorder the list to be on the following form:<\/em><\/p>\n\n<pre>\nL<sub>0<\/sub> &rarr; L<sub>n<\/sub> &rarr; L<sub>1<\/sub> &rarr; L<sub>n - 1<\/sub> &rarr; L<sub>2<\/sub> &rarr; L<sub>n - 2<\/sub> &rarr; &hellip;\n<\/pre>\n\n<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/03\/04\/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2,3,4]\n<strong>Output:<\/strong> [1,4,2,3]\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/03\/09\/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2,3,4,5]\n<strong>Output:<\/strong> [1,5,2,4,3]\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4<\/sup>]<\/code>.<\/li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000<\/code><\/li>\n<\/ul>\n\n\n###\n\n","completion":" [Subscribe to my channel](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw)\\n\\nBefore moving ahead, please read the yesterday\\'s solution.\\nI am reusing the 4th approach\\n[234. Palindrome Linked List](https:\/\/leetcode.com\/problems\/palindrome-linked-list\/solutions\/4908031\/interview-approach-4-approach-list-stack-recursion-two-pointer-approach\/)\\n\\n# Approach#1 ( Using List )\\n\\nSo as I told every Linked List problem can be done via array as well, I mena copy the content in array and solve it as it was an array and then update the list.\\nHere also I could do the same, I will create array and then alternatively will replace values into linked list.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/5b46c6b4-e64f-4a87-af3a-3bc9ed18201d_1711156638.7016938.png)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        vector<int> list;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            list.push_back(curr->val);\\n            curr = curr->next;\\n        }\\n\\n        curr = head;\\n        for (int i = 0; i < list.size(); ++i) {\\n            curr->val = list[i%2 == 0 ? i\/2 : list.size()-(i+1)\/2];\\n            curr = curr->next;\\n        }\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        List<Integer> list = new ArrayList();\\n        ListNode curr = head;\\n        while(curr != null) {\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        for(int i=0;i<list.size();i++) {\\n            head.val = list.get(i%2 == 0 ? i\/2 : list.size()-(i+1)\/2);\\n            head = head.next;\\n        }\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        list_values = []\\n        curr = head\\n        while curr:\\n            list_values.append(curr.val)\\n            curr = curr.next\\n        \\n        # Reorder the list using for loop\\n        curr = head\\n        for i in range(len(list_values)):\\n            if i % 2 == 0:\\n                curr.val = list_values[i \/\/ 2]\\n            else:\\n                curr.val = list_values[len(list_values) - (i + 1) \/\/ 2]\\n            curr = curr.next\\n```\\n```JavaScript []\\nvar reorderList = function(head) {\\n    const list = [];\\n    let curr = head;\\n    while (curr !== null) {\\n        list.push(curr.val);\\n        curr = curr.next;\\n    }\\n\\n    curr = head;\\n    for (let i = 0; i < list.length; i++) {\\n        if (i % 2 === 0) {\\n            curr.val = list[Math.floor(i \/ 2)];\\n        } else {\\n            curr.val = list[list.length - Math.floor((i + 1) \/ 2)];\\n        }\\n        curr = curr.next;\\n    }\\n};\\n```\\n\\n# Approach#2 ( Using Recursion )\\nfor each node , find last node and re-arrange it and then move to next node.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/8ecaeead-0faa-4e4b-a843-95108a1eaa49_1711156369.6611965.png)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void reorderList(ListNode* head) {\\n        helper(head);\\n    }\\n\\n    ListNode* helper(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) return head;\\n        ListNode* last = head;\\n        ListNode* prev = head;\\n        while (last->next != nullptr) {\\n            prev = last;\\n            last = last->next;\\n        }\\n        prev->next = nullptr;\\n        ListNode* next = head->next;\\n        head->next = last;\\n        last->next = helper(next);\\n        return head;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        helper(head);\\n    }\\n\\n    public ListNode helper(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode last = head;\\n        ListNode prev = head;\\n        while(last.next != null) {\\n            prev = last;\\n            last = last.next;\\n        }\\n        prev.next = null;\\n        ListNode next = head.next;\\n        head.next = last;\\n        last.next = solve(next);\\n        return head;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        self.helper(head)\\n\\n    def helper(self, head: Optional[ListNode]) -> ListNode:\\n        if head is None or head.next is None:\\n            return head\\n        last = head\\n        prev = head\\n        while last.next:\\n            prev = last\\n            last = last.next\\n        prev.next = None\\n        next_node = head.next\\n        head.next = last\\n        last.next = self.helper(next_node)\\n        return head\\n```\\n```Javascript []\\nvar reorderList = function(head) {\\n    helper(head);\\n};\\n\\nvar helper = function(head) {\\n    if (head === null || head.next === null) {\\n        return head;\\n    }\\n    let last = head;\\n    let prev = head;\\n    while (last.next !== null) {\\n        prev = last;\\n        last = last.next;\\n    }\\n    prev.next = null;\\n    const next = head.next;\\n    head.next = last;\\n    last.next = helper(next);\\n    return head;\\n};\\n```\\n\\n# Approach#3 ( Recursion - Only Smart A** can understand )\\nJust think of like you know that end of the linked list is always middle and next middle. then we can append at the start previous of middle with next of next middle and so on.\\n\\nI think you didn\\'t understand this, let me draw for you.\\nDraft: ( I will draw here and will update code for other languages , till then you can try to think like how it\\'s possible , Take your time. )\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/def334fb-d660-469f-8642-be91d30747ba_1711165955.4785228.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/e42ec9af-4dbd-406e-9c82-084e9b0810d1_1711165910.3344858.png)\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public void reorderList(ListNode head) {\\n        helper(head, head.next);\\n    }\\n\\n    public ListNode[] helper(ListNode slow, ListNode fast) {\\n        if(fast == null || fast.next == null) \\n            return new ListNode[]{slow, fast == null ? slow : slow.next};\\n        ListNode[] ret = helper(slow.next, fast.next.next);\\n        ListNode next = ret[1].next;\\n        if(ret[1].next != null) ret[1].next = ret[1].next.next;\\n        slow.next = next;\\n        if(next != null) next.next = ret[0];\\n        return new ListNode[]{slow, ret[1]};\\n    }\\n}\\n```\\n\\n# Approach#4 ( Like Palindrome Linked List )\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo Basically\\nL0 -> LN -> L1 -> LN-1 .....\\nDid you find any similarity between palindrome linked list and this one, if yes congratulations you made this problem easy.\\n\\n```Steps []\\n- first find middle node\\n- reverse the second half\\n- now merge first and second half alternatively\\n```\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/c744f01f-2d58-412f-8ebd-6870edb6ba00_1711153504.1462193.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    void reorderList(ListNode* head) {\\n        if (head == nullptr) return;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while (fast != nullptr && fast->next != nullptr) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        ListNode* rev = reverse(slow->next);\\n        slow->next = nullptr;\\n\\n        while (rev != nullptr) {\\n            ListNode* headNext = head->next;\\n            ListNode* revNext = rev->next;\\n            head->next = rev;\\n            rev->next = headNext;\\n            head = headNext;\\n            rev = revNext;\\n        }\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    public void reorderList(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while(fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode rev = reverse(slow.next); \/\/ reverse second list\\n        slow.next = null;\\n\\n        \/\/ now add node one by one\\n        while(rev != null) {\\n            ListNode headNext = head.next;\\n            ListNode revNext = rev.next;\\n            head.next = rev;\\n            rev.next = headNext;\\n            head = headNext;\\n            rev = revNext;\\n        }\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def reverse(self, head: ListNode) -> ListNode:\\n        prev = None\\n        curr = head\\n        while curr:\\n            next_temp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_temp\\n        return prev\\n\\n    def reorderList(self, head: Optional[ListNode]) -> None:\\n        if head is None:\\n            return\\n\\n        # Find the middle of the list\\n        slow = head\\n        fast = head.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        # Reverse the second half\\n        rev = self.reverse(slow.next)\\n        slow.next = None\\n\\n        # Reorder one by one\\n        while rev:\\n            head_next = head.next\\n            rev_next = rev.next\\n            head.next = rev\\n            rev.next = head_next\\n            head = head_next\\n            rev = rev_next\\n```\\n```Javascript []\\nvar reverse = function(head) {\\n    let prev = null;\\n    let curr = head;\\n    while (curr !== null) {\\n        let nextTemp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = nextTemp;\\n    }\\n    return prev;\\n}\\n\\nvar reorderList = function(head) {\\n    if (!head) return;\\n\\n    let slow = head;\\n    let fast = head.next;\\n    while (fast && fast.next) {\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n\\n    let rev = reverse(slow.next);\\n    slow.next = null;\\n\\n    while (rev) {\\n        let headNext = head.next;\\n        let revNext = rev.next;\\n        head.next = rev;\\n        rev.next = headNext;\\n        head = headNext;\\n        rev = revNext;\\n    }\\n};\\n```\\n\\nIf you like this post, please upvote it.\n"},
{"prompt":"<p>Given the <code>head<\/code> of a singly linked list, reverse the list, and return <em>the reversed list<\/em>.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/02\/19\/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2,3,4,5]\n<strong>Output:<\/strong> [5,4,3,2,1]\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/02\/19\/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2]\n<strong>Output:<\/strong> [2,1]\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> head = []\n<strong>Output:<\/strong> []\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]<\/code>.<\/li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000<\/code><\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<p><strong>Follow up:<\/strong> A linked list can be reversed either iteratively or recursively. Could you implement both?<\/p>\n\n\n###\n\n","completion":" ```Interview []\\nIf you get this question in your interview and you haven\\'t solve this\\nit\\'s less possible to comeup with 3rd approach and to be honest questions\\non Binary Tree and Linked List are mostly asked that you have already\\nseen, I mean there is very less variety available until and unless\\ninterview himself made the questions but logic would be same.\\n```\\n\\nAnimation is at the end.\\n\\n\\n# Approach#1 ( Recursion )\\n<!-- Describe your approach to solving the problem. -->\\nMove to the next node till we reach the last node, now return this node to prev node, now change the returned node\\'s next to prev node. and now return prev node and do this recursively.\\nRemeber to change the curr node\\'s next to null, else you will end up in creating cycle.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(head);\\n        return newHead;\\n    }\\n\\n    public ListNode reverseListHelper(ListNode head) {\\n        if(head.next == null) return newHead = head;\\n        ListNode nextNode = reverseListHelper(head.next);\\n        nextNode.next = head;\\n        head.next = null;\\n        return head;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* newHead = nullptr;\\n\\n    ListNode* reverseList(ListNode* head) {\\n        if (head == nullptr) return nullptr;\\n        reverseListHelper(head);\\n        return newHead;\\n    }\\n\\n    ListNode* reverseListHelper(ListNode* head) {\\n        if (head->next == nullptr) {\\n            newHead = head;\\n            return head;\\n        }\\n        ListNode* nextNode = reverseListHelper(head->next);\\n        nextNode->next = head;\\n        head->next = nullptr;\\n        return head;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return None\\n        self.reverseListHelper(head)\\n        return self.newHead\\n    \\n    def reverseListHelper(self, head: ListNode) -> ListNode:\\n        if head.next is None:\\n            self.newHead = head\\n            return head\\n        nextNode = self.reverseListHelper(head.next)\\n        nextNode.next = head\\n        head.next = None\\n        return head\\n```\\n\\n# Approach#1 Optimisation\\nSince every time we will change the node\\'s next pointer to previous, so we don\\'t need to mark it as null except the first node, which has no previous node. So once we are done with recursion we will change first node\\'s next to null.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(head);\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public ListNode reverseListHelper(ListNode head) {\\n        if(head.next == null) return newHead = head;\\n        ListNode nextNode = reverseListHelper(head.next);\\n        nextNode.next = head;\\n        return head;\\n    }\\n}\\n```\\n\\n# Approach#2 ( Recursion , Early Poitner Change )\\nHere we will track prev and current node in our recursion stack and will change the current\\'s next to prev and then move to next node. now for next node, prev would be the current node.\\n\\n# Code\\n```\\n\/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n *\/\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(null, head);\\n        return newHead;\\n    }\\n\\n    public void reverseListHelper(ListNode prev, ListNode head) {\\n        if(head == null) return;\\n        if(head.next == null) {\\n            newHead = head;\\n        }\\n        ListNode next = head.next;\\n        head.next = prev;\\n        reverseListHelper(head, next);\\n    }\\n}\\n```\\n\\n# Approach#3 ( Two Pointer )\\nSee this video animation, you will understand it.\\nhttps:\/\/youtube.com\/shorts\/Du4elALktj8\\n\\nThe idea is always make sure, you store previous node and change current node\\'s next to previous node. and move to next node now since we are changing current node\\'s next so first we will store current node\\'s next node so that we don\\'t lose the node and that\\'s it.\\n\\nNow at the end your previous node would be the head of the linked list.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev = nullptr;\\n        ListNode *curr = head;\\n        while (curr != nullptr) {\\n            ListNode *nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            next = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next\\n        return prev\\n```\\n```JavaScript []\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let curr = head;\\n    while (curr !== null) {\\n        let nextTemp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = nextTemp;\\n    }\\n    return prev;\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun reverseList(head: ListNode?): ListNode? {\\n        var prev: ListNode? = null\\n        var curr = head\\n        while (curr != null) {\\n            val nextTemp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nextTemp\\n        }\\n        return prev\\n    }\\n}\\n```\\n\\nAnimation Video for Approach - 3 ( Open in new Tab for better experience )\\nor visit this link for slowed version\\nhttps:\/\/youtube.com\/shorts\/Du4elALktj8\\n![Reverse Linked List - Animation.gif](https:\/\/assets.leetcode.com\/users\/images\/fc58d7b7-caba-4f22-ab25-389274e331a3_1710993442.234485.gif)\\n\\nIf you like the blog, please upvote it.\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"}