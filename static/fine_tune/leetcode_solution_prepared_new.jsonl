{"prompt":"<p>Given an array of integers <code>nums<\/code> containing&nbsp;<code>n + 1<\/code> integers where each integer is in the range <code>[1, n]<\/code> inclusive.<\/p>\n\n<p>There is only <strong>one repeated number<\/strong> in <code>nums<\/code>, return <em>this&nbsp;repeated&nbsp;number<\/em>.<\/p>\n\n<p>You must solve the problem <strong>without<\/strong> modifying the array <code>nums<\/code>&nbsp;and using only constant extra space.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [1,3,4,2,2]\n<strong>Output:<\/strong> 2\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,1,3,4,2]\n<strong>Output:<\/strong> 3\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,3,3,3,3]\n<strong>Output:<\/strong> 3<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums.length == n + 1<\/code><\/li>\n\t<li><code>1 &lt;= nums[i] &lt;= n<\/code><\/li>\n\t<li>All the integers in <code>nums<\/code> appear only <strong>once<\/strong> except for <strong>precisely one integer<\/strong> which appears <strong>two or more<\/strong> times.<\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<p><b>Follow up:<\/b><\/p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums<\/code>?<\/li>\n\t<li>Can you solve the problem in linear runtime complexity?<\/li>\n<\/ul>\n\n\n###\n\n","completion":" ### [Subscribe to My Channel ( Target 1K Subscribers )](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw)\\n\\n## Video Solution\\nI will be live today around 12:30 PM [here](https:\/\/www.youtube.com\/watch?v=wIRzisDcFSE&ab_channel=CSIITIAN)\\nhttps:\/\/www.youtube.com\/watch?v=wIRzisDcFSE&ab_channel=CSIITIAN\\n\\nOnly Approach#5 and Approach#7 has code in C++, Java, Python3 and Javascript.\\n\\n# 1. Brute Force ( TLE )\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n            for(int j=i+1;j<nums.length;j++)\\n                if(nums[i] == nums[j]) return nums[i];\\n        return -1;\\n    }\\n}\\n```\\n\\n# 2. Sort the array and check adjacent elements\\nTime Complexity: O(n*logn)\\nSpace Complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-1;i++)\\n            if(nums[i] == nums[i+1]) return nums[i];\\n        return -1;\\n    }\\n}\\n```\\n\\n# 3. Using HashSet to store visited nodes\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        Set<Integer> set = new HashSet();\\n        for(int i=0;i<nums.length;i++) {\\n            if(set.contains(nums[i])) return nums[i];\\n            set.add(nums[i]);\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# 4. Using boolean array\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int n = nums.length;\\n        boolean[] set = new boolean[n+1];\\n        for(int i=0;i<n;i++) {\\n            if(set[nums[i]]) return nums[i];\\n            set[nums[i]] = true;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```Note []\\nIn Approach 5 and 6, you might be thinking how we can do that,\\nsince we are not allowed to modify the existing array.\\nDon\\'t worry, once we perform answer we can revert the changes.\\nI haven\\'t written code for that.\\n```\\n\\n# 5. Mark visited element negative\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            int ind = abs(nums[i]);\\n            if (nums[ind] < 0) {\\n                return ind;\\n            }\\n            nums[ind] = -nums[ind];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++) {\\n            int ind = Math.abs(nums[i]);\\n            if(nums[ind] < 0) {\\n                return ind;\\n            }\\n            nums[ind] = -nums[ind];\\n        }\\n        return -1;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            ind = abs(nums[i])\\n            if nums[ind] < 0:\\n                return ind\\n            nums[ind] = -nums[ind]\\n        return -1\\n```\\n```Javascript []\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    for (let i = 0; i < nums.length; i++) {\\n        let ind = Math.abs(nums[i]);\\n        if (nums[ind] < 0) {\\n            return ind;\\n        }\\n        nums[ind] = -nums[ind];\\n    }\\n    return -1;\\n};\\n```\\n\\n# 6. Using Mod ( 1e5 + 1 )\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```java\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int mod = (int)1e5 + 1;\\n        for(int i=0;i<nums.length;i++) {\\n            int ind = Math.abs(nums[i])%mod;\\n            if(nums[ind]\/mod > 0) {\\n                return ind;\\n            }\\n            nums[ind] += mod;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# 7. Hare & Tortoise Method\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do {\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while (slow != fast);\\n        \\n        fast = nums[0];\\n        while (slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return fast;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int findDuplicate(int[] nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n        do { \/\/ we are sure that at least one duplicate is there\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n        } while(slow != fast);\\n        \/\/ find the head of loop\\n        fast = nums[0];\\n        while(slow != fast) {\\n            slow = nums[slow];\\n            fast = nums[fast];\\n        }\\n        return fast;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def findDuplicate(self, nums: List[int]) -> int:\\n        slow = nums[0]\\n        fast = nums[0]\\n        while True:\\n            slow = nums[slow]\\n            fast = nums[nums[fast]]\\n            if slow == fast:\\n                break\\n        fast = nums[0]\\n        while slow != fast:\\n            slow = nums[slow]\\n            fast = nums[fast]\\n        return fast\\n```\\n```Javascript []\\nvar findDuplicate = function(nums) {\\n    let slow = nums[0];\\n    let fast = nums[0];\\n    do {\\n        slow = nums[slow];\\n        fast = nums[nums[fast]];\\n    } while (slow != fast);\\n    \\n    fast = nums[0];\\n    while (slow != fast) {\\n        slow = nums[slow];\\n        fast = nums[fast];\\n    }\\n    return fast;\\n};\\n```\\n\\nIf you have come so far, don\\'t forget to upvote the post !\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"}
{"prompt":"<p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly<\/i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.<\/p>\n\n<p>Given a tree of <code>n<\/code> nodes&nbsp;labelled from <code>0<\/code> to <code>n - 1<\/code>, and an array of&nbsp;<code>n - 1<\/code>&nbsp;<code>edges<\/code> where <code>edges[i] = [a<sub>i<\/sub>, b<sub>i<\/sub>]<\/code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i<\/sub><\/code> and&nbsp;<code>b<sub>i<\/sub><\/code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x<\/code> as the root, the result tree has height <code>h<\/code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)<\/code>)&nbsp; are called <strong>minimum height trees<\/strong> (MHTs).<\/p>\n\n<p>Return <em>a list of all <strong>MHTs&#39;<\/strong> root labels<\/em>.&nbsp;You can return the answer in <strong>any order<\/strong>.<\/p>\n\n<p>The <strong>height<\/strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/09\/01\/e1.jpg\" style=\"width: 800px; height: 213px;\" \/>\n<pre>\n<strong>Input:<\/strong> n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>Output:<\/strong> [1]\n<strong>Explanation:<\/strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2020\/09\/01\/e2.jpg\" style=\"width: 800px; height: 321px;\" \/>\n<pre>\n<strong>Input:<\/strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>Output:<\/strong> [3,4]\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4<\/sup><\/code><\/li>\n\t<li><code>edges.length == n - 1<\/code><\/li>\n\t<li><code>0 &lt;= a<sub>i<\/sub>, b<sub>i<\/sub> &lt; n<\/code><\/li>\n\t<li><code>a<sub>i<\/sub> != b<sub>i<\/sub><\/code><\/li>\n\t<li>All the pairs <code>(a<sub>i<\/sub>, b<sub>i<\/sub>)<\/code> are distinct.<\/li>\n\t<li>The given input is <strong>guaranteed<\/strong> to be a tree and there will be <strong>no repeated<\/strong> edges.<\/li>\n<\/ul>\n\n\n###\n\n","completion":" ## Subscribe to My Channel ( Target : 1K )\\nhttps:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw\\n\\n# Approach\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/8ec76bc8-0331-4529-ac33-20a0c805d484_1713833772.2551377.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/227896ab-95b0-4283-9403-bb9f726a9f0f_1713833806.6421852.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/085bd2e8-bc51-4d16-a61a-e53e30f03803_1713833840.6502717.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/0938034b-cf00-452d-9561-374972c74a86_1713833883.439522.png)\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/280c1dfe-282e-484b-89e9-a28a625a78d0_1713833908.8626156.png)\\n\\n\\n# Code Explanation\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/82ceedf6-5188-42e7-bdcd-24a36c8ed585_1713834144.6413438.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if(n == 1) return Collections.singletonList(0);\\n        \\n        int ind[] = new int[n];\\n        Map<Integer, List<Integer>> map = new HashMap();\\n        for(int[] edge: edges) {\\n            ind[edge[0]]++;\\n            ind[edge[1]]++;\\n            map.putIfAbsent(edge[0], new ArrayList());\\n            map.putIfAbsent(edge[1], new ArrayList());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n\\n        Queue<Integer> queue = new LinkedList();\\n        for(int i=0;i<ind.length;i++) {\\n            if(ind[i] == 1) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        int processed = 0;\\n        while(n - processed > 2) {\\n            int size = queue.size();\\n            processed += size;\\n            for(int i=0;i<size;i++) {\\n                int poll = queue.poll();\\n                for(int adj: map.get(poll)) {\\n                    if(--ind[adj] == 1) {\\n                        queue.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n\\n        List<Integer> list = new ArrayList();\\n        list.addAll(queue);\\n        return list;\\n    }\\n}\\n```\\n\\n\\n# Optimised Code ( by Chat GPT )\\n\\n```java []\\nclass Solution {\\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\\n        if (n == 1) return Collections.singletonList(0);\\n        \\n        int[] degree = new int[n];\\n        Map<Integer, List<Integer>> adjacencyList = new HashMap<>();\\n        for (int[] edge : edges) {\\n            degree[edge[0]]++;\\n            degree[edge[1]]++;\\n            adjacencyList.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(edge[1]);\\n            adjacencyList.computeIfAbsent(edge[1], x -> new ArrayList<>()).add(edge[0]);\\n        }\\n\\n        Queue<Integer> leaves = new LinkedList<>();\\n        for (int i = 0; i < degree.length; i++) {\\n            if (degree[i] == 1) {\\n                leaves.add(i);\\n            }\\n        }\\n\\n        int remainingNodes = n;\\n        while (remainingNodes > 2) {\\n            int size = leaves.size();\\n            remainingNodes -= size;\\n            for (int i = 0; i < size; i++) {\\n                int leaf = leaves.poll();\\n                for (int neighbor : adjacencyList.get(leaf)) {\\n                    if (--degree[neighbor] == 1) {\\n                        leaves.add(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(leaves);\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\\n        if (n == 1) return {0};\\n    \\n        std::vector<std::list<int>> adjacency_list(n);\\n        std::vector<int> degree(n, 0);\\n        for (auto& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            adjacency_list[u].push_back(v);\\n            adjacency_list[v].push_back(u);\\n            degree[u]++;\\n            degree[v]++;\\n        }\\n        \\n        std::queue<int> leaves;\\n        for (int i = 0; i < n; ++i) {\\n            if (degree[i] == 1) leaves.push(i);\\n        }\\n        \\n        int remainingNodes = n;\\n        while (remainingNodes > 2) {\\n            int leavesCount = leaves.size();\\n            remainingNodes -= leavesCount;\\n            for (int i = 0; i < leavesCount; ++i) {\\n                int leaf = leaves.front();\\n                leaves.pop();\\n                for (int neighbor : adjacency_list[leaf]) {\\n                    if (--degree[neighbor] == 1) {\\n                        leaves.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        std::vector<int> result;\\n        while (!leaves.empty()) {\\n            result.push_back(leaves.front());\\n            leaves.pop();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\\n        if n == 1:\\n            return [0]\\n        \\n        # Initialize the adjacency list and degree of each node\\n        adjacency_list = defaultdict(list)\\n        degree = [0] * n\\n        for u, v in edges:\\n            adjacency_list[u].append(v)\\n            adjacency_list[v].append(u)\\n            degree[u] += 1\\n            degree[v] += 1\\n        \\n        # Initialize leaves queue\\n        leaves = deque([i for i in range(n) if degree[i] == 1])\\n        \\n        # Trim leaves until 2 or fewer nodes remain\\n        remaining_nodes = n\\n        while remaining_nodes > 2:\\n            leaves_count = len(leaves)\\n            remaining_nodes -= leaves_count\\n            for _ in range(leaves_count):\\n                leaf = leaves.popleft()\\n                for neighbor in adjacency_list[leaf]:\\n                    degree[neighbor] -= 1\\n                    if degree[neighbor] == 1:\\n                        leaves.append(neighbor)\\n        \\n        return list(leaves)\\n```\n"}
{"prompt":"<p>You are given a <strong>0-indexed<\/strong> integer array <code>nums<\/code> of <strong>even<\/strong> length consisting of an <strong>equal<\/strong> number of positive and negative integers.<\/p>\n\n<p>You should return the array of nums such that the the array follows the given conditions:<\/p>\n\n<ol>\n\t<li>Every <strong>consecutive pair<\/strong> of integers have <strong>opposite signs<\/strong>.<\/li>\n\t<li>For all integers with the same sign, the <strong>order<\/strong> in which they were present in <code>nums<\/code> is <strong>preserved<\/strong>.<\/li>\n\t<li>The rearranged array begins with a positive integer.<\/li>\n<\/ol>\n\n<p>Return <em>the modified array after rearranging the elements to satisfy the aforementioned conditions<\/em>.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [3,1,-2,-5,2,-4]\n<strong>Output:<\/strong> [3,-2,1,-5,2,-4]\n<strong>Explanation:<\/strong>\nThe positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].\nThe only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].\nOther ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  \n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> nums = [-1,1]\n<strong>Output:<\/strong> [1,-1]\n<strong>Explanation:<\/strong>\n1 is the only positive integer and -1 the only negative integer in nums.\nSo nums is rearranged to [1,-1].\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 2 * 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums.length<\/code> is <strong>even<\/strong><\/li>\n\t<li><code>1 &lt;= |nums[i]| &lt;= 10<sup>5<\/sup><\/code><\/li>\n\t<li><code>nums<\/code> consists of <strong>equal<\/strong> number of positive and negative integers.<\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\nIt is not required to do the modifications in-place.\n\n###\n\n","completion":" Hi Everyone, Welcome back to our interview series !\\n\\n## Video Solution\\nhttps:\/\/youtu.be\/S-VLkFLOaWA\\n\\nSo if this question has been asked to you then it means you will most likely to get followed question as what if the order doesn\\'t matter.\\nMeans you just have to put positive and negative in alternative order.\\nEx: [4, -2, -5, 9]\\nSo your answer could be [4, -5, 9, 2] since order doesn\\'t matter.\\n\\nSo first let\\'s focus on the question where order matters.\\n\\n```Note []\\nNo. of positives = No. of negatives\\nSo if I start first from positive if will end at negative. \\nor Either I can start first from negative.\\nWe will follow first one , which is starting from positive.\\nSo next positive would be after 2 index and so on in the gap of 2.\\nOur negative would start from 1 and would step up by 2 each time.\\n```\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/1c2dda55-157f-4129-a8cd-30628727fb39_1707874686.247468.png)\\n\\n\\nSince we have fixed index for positive and negative. I can fetch the positives and negatives in an array and then one by one put into result array.\\n\\n```DryRun []\\nEx: [3,1,-2,-5,2,-4]\\nPos: [3, 1, 2]\\nNeg: [-2, -5, -4]\\n\\nNow put all positives at even place\\nresult: [3, _, 1, _, 2, _] ( here _ means we have not inserted)\\nNow put all negatives at odd place\\nresult: [3, -2, 1, -5, 2, -4]\\n\\nSo we can see that now positive are all at even index and negatives\\nare all at odd index in their original order.\\n```\\n\\n`You` : Are we good with this approach ?\\n`Interviewer`: Let\\'s discuss time and space complexity, then we can go ahead.\\n`You` : Space Compelxity would be O(n) to store positives and negatives. and Time Complexity would also be O(n) we will traverse each element twice. Once for filling in positives and negatives list and second time for inserting into result array at their specified position.\\n`Interviewer` : Cool ! Then write code for it.\\n\\n*Le Keyboard: (TAPA, TAP, TAPA, TAP ... )\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        List<Integer> pos = new ArrayList();\\n        List<Integer> neg = new ArrayList();\\n        \\n        for(int x: nums) {\\n            if(x >= 0) pos.add(x);\\n            else neg.add(x);\\n        }\\n\\n        for(int i=0;i<nums.length;i++) {\\n            if(i%2 == 0) {\\n                nums[i] = pos.get(i\/2);\\n            } else {\\n                nums[i] = neg.get(i\/2);\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```\\n\\n`Interviewer` : Here you have used two iteration, can you do it in one iterations ?\\n`You` : Okay, let me think. and What about space ?\\n`Interviewer`: Space can be O(n) and if you can optimise the space as well then go ahead.\\n`You` : Ok, I think since we need to preserve order It would not be possible to done it in-place. So I will use one array of size n. Since I know if the element is even it\\'s position would be 0 for the first time and next time += 2 and so on.\\n\\nSo I will use two pointer for even and odd which will be at the position where I can insert even and odd element.\\n\\n`Interviewer` : Okay, write code for it.\\n`You` : Sure.\\n\\n*Le Keyboard: (TAPA, TAP, TAPA, TAP ... )\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 0);\\n        int pos = 0, neg = 1;\\n        for(int i = 0; i < n; ++i) {\\n            if(nums[i] >= 0) {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else {\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int pos = 0, neg = 1;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] >= 0) {\\n                ans[pos] = nums[i];\\n                pos += 2;\\n            }\\n            else {\\n                ans[neg] = nums[i];\\n                neg += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        pos, neg = 0, 1\\n        for i in range(n):\\n            if nums[i] >= 0:\\n                ans[pos] = nums[i]\\n                pos += 2\\n            else:\\n                ans[neg] = nums[i]\\n                neg += 2\\n        return ans\\n```\\n\\n```Note []\\nHere time complexity would be O(n) because in question we have been \\nasked to modify the input array itself. If we were asked not to modify\\nit we would be having our time complexity as O(1).\\n```\\n\\n`Interviewer` : We have some time left, I have one follow up question on this what if the order doesn\\'t matter , can you do that in-place ?\\n`You` : Ok, Let me think.\\n\\nAs we know that order doesn\\'t matter and also we have equal no. of positive and negatives.\\nSo what if positive is not at the correct index, we can get negative and swap it. same for the negative if it is not at correct index , we can get positive and swap.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/2b63530a-300a-40b6-b6db-e10edabfeffc_1707875931.6341405.png)\\n\\n`Interviewer` : Ok, what about time and space complexity here ?\\n`You`: As we are swapping the element in existing array itself, we don\\'t need any extra space so space complexity would be O(1).\\nand Time Complexity would be O(n) because we will traverse n elements once.\\n`Interviewer` : You can write code for this.\\n`You` : Sure !\\n\\n```\\nclass Solution {\\n    public int[] rearrangeArray(int[] nums) {\\n        int n = nums.length;\\n        int pos = 0, neg = 1;\\n        while(pos < n && neg < n) {\\n            if(nums[pos] >= 0) pos += 2;\\n            else if(nums[neg] < 0) neg += 2;\\n            else {\\n                int temp = nums[pos];\\n                nums[pos] = nums[neg];\\n                nums[neg] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n\\n`Interviewer` : I am done with my side, if you have any questions let me know.\\n`You` : No. ( FO )\\n\\n```Note []\\nThere is one more version to this question, where instead of \\npositive and negatives we have even and odd. So the concept \\nwould remain same just some condition will change.\\n```\\n\\nSome more follow up questions\\n```Similar-Questions []\\n1. What if no. of positive and negative are not equals \\n   and once one of the items finished, rest can be consecutives ?\\n\\n2. What if you have to return all positives together on \\n   left side and all negatives together in right side. \\n( This one I got in my interview, where I was asked to segreate \\neven and odd numbers. So I\\'ve done this using two pointer. )\\n\\n3. Segregate positive, negatives and zeros.\\n( This questions uses three pointer, one for positive , one for zero\\nand one for negative. )\\nThe above question is similar to the below question give it a try\\nhttps:\/\/leetcode.com\/problems\/partition-array-according-to-given-pivot\/\\n```\\n\\n\\nThanks All !!!\\nIf You have came this for, Don\\'t forget to upvote it !!!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"}
{"prompt":"<p>Given an array <code>nums<\/code> of size <code>n<\/code>, return <em>the majority element<\/em>.<\/p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n \/ 2&rfloor;<\/code> times. You may assume that the majority element always exists in the array.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<pre><strong>Input:<\/strong> nums = [3,2,3]\n<strong>Output:<\/strong> 3\n<\/pre><p><strong class=\"example\">Example 2:<\/strong><\/p>\n<pre><strong>Input:<\/strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:<\/strong> 2\n<\/pre>\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>n == nums.length<\/code><\/li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4<\/sup><\/code><\/li>\n\t<li><code>-10<sup>9<\/sup> &lt;= nums[i] &lt;= 10<sup>9<\/sup><\/code><\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<strong>Follow-up:<\/strong> Could you solve the problem in linear time and in <code>O(1)<\/code> space?\n\n###\n\n","completion":" Hi All, I hope you are doing great !\\n\\n```Note []\\nBefore moving into interview, I\\'ve something for you !!! \\n\\nWhen I was in 9th class, my teacher ask us a question, He drew 2 lines\\non board first one was longer and second one was shorter and ask us how\\nthe second line can be longer than first one.\\n\\nSome students said we can erase the first line a little bit to make \\nit shorter than the second one. and some said it is impossible.\\nLater on teacher expanded the shorter one to make it longer.\\n\\nI\\'ve learned one thing from that day that\\n- In your life if you want to grow, work hard. Don\\'t defame others.\\n```\\n\\n## Video Solution ( in Hindi Language )\\nhttps:\/\/youtu.be\/m3FFBjb--cs\\n\\nIf this has been asked in interview first thing would be simple solution that comes out of your mind easily.\\n\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/a69d3006-c1b0-41bc-98aa-383009ff2dcc_1707701880.8592477.png)\\n\\n\\n\\nBrute Force Solution: For each element we will check the count in array and if it is more than n\/2 we will return our result.\\n\\n( Note: Interviewer might not want you to code this approach )\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++) {\\n            int count = 1;\\n            for(int j=i+1;j<n;j++) {\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count > n\/2) return nums[i];\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n`Interviewer` : What would be time and space complexity ?\\n`You` : Time Complexity would be O(n^2) because we have two for loops. and Space Complexity would be O(1).\\n\\n`Interviewer` : Can you further optimise it ?\\n\\n```Tip#1 []\\nIf this is the first question interviewer ask you can drag the \\ninterview. Also keep in mind the time if you spend so much time \\nhere other problems might be hard and might require more time. \\nSo Be aware of that.\\n```\\n\\n`You` : Yes, I think we can sort the array, as we know the frequency should be more than \\u230An \/ 2\\u230B. Our middle element will be our answer.\\n\\n`Interviewer` : How you so sure about this ?\\n\\n`You` : ( Because I have proof ) Ok, so when we sort array all same element would be at same place. Now length more than \\u230An \/ 2\\u230B will always cross the middle element, even if it starts from the first index or it ends at the last index.\\n\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums[nums.length \/ 2];\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return nums[len(nums) \/\/ 2]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        return nums[nums.size() \/ 2];\\n    }\\n};\\n```\\n\\n`Interviewer` : Here what would be your time and space complexity ?\\n\\n`You` : Time Complexity would be O(n*logn) due to sorting and Space Complexity would be O(1).\\n\\n\\n`Interviewer` : Think of something that can be done in O(n) time.\\n\\n`You` : Yes, I think we can use map here. We will store each number\\'s frequency and whichever number will have frequency more than \\u230An \/ 2\\u230B will be our answer.\\n\\n```Java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer, Integer> freqCount = new HashMap();\\n        for(int num: nums) {\\n            freqCount.put(num, freqCount.getOrDefault(num, 0) + 1);\\n        }\\n        for(Map.Entry<Integer, Integer> entry: freqCount.entrySet()) {\\n            if(entry.getValue() > n\/2) return entry.getKey();\\n        }\\n        return -1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        freq_count = {}\\n        n = len(nums)\\n        for num in nums:\\n            freq_count[num] = freq_count.get(num, 0) + 1\\n        for num, count in freq_count.items():\\n            if count > n \/\/ 2:\\n                return num\\n        return -1\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map<int, int> freqCount;\\n        int n = nums.size();\\n        for(int num : nums) {\\n            ++freqCount[num];\\n        }\\n        for(auto& entry : freqCount) {\\n            if(entry.second > n \/ 2) return entry.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n`Interviewer` : What would be time and space complexity here ?\\n\\n`You` : Time Complexity would be O(n) iterating through each array two times and Space Complexity would be O(n) for storing frequencies.\\n\\n`Interviewer` : Can you think of something with O(1) space ?\\n\\n```Tip#2 []\\nHere if you already know the Boyer Moore Voting Algorithm, \\nyou can directly say you will use this algorithm. \\nBe honest in your interview.\\nIf you know something it means that you are well prepared for this\\ninterview and you are honest It is sign of good programmers.\\n```\\n\\n`You` : Hmm ! Let me think !\\n`Interviewer` : ( Giving Hint ) Don\\'t you agree that the answer would always be more than the total count of other number.\\n`You` : Yes ! I agree. ( MF, I know that f**king algorithm you are heading towards )\\n`Interviewer` : Ok, what if every one number will cancel other distinct number, the number left at the end would be our answer.\\n`You` : Yeah, I got it. If I can pick first number as my answer then going forward I can increment the count if we have similar number and decrement if we have distinct number, if at any time I have count 0, I will assign my current number as answer and will proceed further.\\n`Interviewer` : Yes, Correct !\\n`You` : \\nLet\\'s see through test cases\\n[1, 1, 2]\\nNow let\\'s say our answer is 1, for\\nindex 0 -> count - 1\\nindex 1 -> count - 2\\nindex 2 -> count 1\\nso for 1 our count is 1 and 1 would be our answer.\\n\\nlet\\'s see one more test cases\\n[1, 2, 1]\\nindex 0 -> count - 1\\nindex 1 -> count - 0\\nnow change our answer to 2 and count - 1\\nindex 2 -> count - 0\\nnow change our answer to 1 and count - 1\\nSo our final answer here would be 1.\\n\\n`Interviewer` : JFYI, It is called `Boyer-Moore Majority Vote Algorithm`.\\n\\n```Note\\nIf you guys already know this algorithm you can directly tell \\nthe interviewer about this.\\n```\\n\\n`Interviewer` : Let\\'s write code for this.\\n`You` : Le keyboard ( TAPA TAP TAPA TAP .... )\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int majorityElement(int[] nums) {\\n        int count = 1;\\n        int ans = nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i] != ans) {\\n                count--;\\n            } else {\\n                count++;\\n            }\\n            if(count == 0) {\\n                ans = nums[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count = 1\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] != ans:\\n                count -= 1\\n            else:\\n                count += 1\\n            \\n            if count == 0:\\n                ans = nums[i]\\n                count = 1\\n        \\n        return ans\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int count = 1;\\n        int ans = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != ans) {\\n                count--;\\n            } else {\\n                count++;\\n            }\\n            if(count == 0) {\\n                ans = nums[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`Interviewer` : Good, What about Time and Space Complexity ?\\n\\n`You` : Time Complexity would be O(n) we have done in one traversal and Space Complexity would be O(1).\\n\\n`Interviewer` : Tell me one thing, have you seen this problem earlier ?\\n\\n`You` : Yes ( MF, you are not the one who invented this ) , But I was not aware of that algorithm. ( If you know tell ***honestly*** this is for those  who don\\'t know and came up with approach with some hints from interviewer .)\\n\\n`Interviewer` : Let\\'s move to the next problem.\\n\\nThat\\'s it guys, I hope you really enjoyed reading this blog. If yes let me know in comment section.\\nIf you have any doubts let me know , I am not an expert but I will try my best to answer.\\n\\nThank you !!! Bye Bye !!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"}
{"prompt":"<p>Given an integer <code>n<\/code>, return <em>the least number of perfect square numbers that sum to<\/em> <code>n<\/code>.<\/p>\n\n<p>A <strong>perfect square<\/strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1<\/code>, <code>4<\/code>, <code>9<\/code>, and <code>16<\/code> are perfect squares while <code>3<\/code> and <code>11<\/code> are not.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> n = 12\n<strong>Output:<\/strong> 3\n<strong>Explanation:<\/strong> 12 = 4 + 4 + 4.\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> n = 13\n<strong>Output:<\/strong> 2\n<strong>Explanation:<\/strong> 13 = 4 + 9.\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4<\/sup><\/code><\/li>\n<\/ul>\n\n\n###\n\n","completion":" ## Youtube Video Solution ( in Hindi )\\nhttps:\/\/www.youtube.com\/watch?v=hGYemyJ8ePc&ab_channel=CSIITIAN\\n\\n**Edit:** *as [iempriyanshu2](https:\/\/leetcode.com\/iempriyanshu2\/) suggests, we will never reach negative because we are making sure we always perform operation for less than or equal to n. So going forward in this blog you can ignore the negative condition.* - Thanks [iempriyanshu2](https:\/\/leetcode.com\/iempriyanshu2\/)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all if we go greedy like for 12, picking up the maximum closest square it would fail in our first test case\\n```\\n12 -> 9 + 1 + 1 + 1 ( Greedy Solution Failed )\\n12 -> 4 + 4 + 4 ( Actual Answer )\\n```\\n\\nSo we will iterate through all possible squares and will try to minimise the count.\\n\\n```\\n\/\/ Base Case\\n1. n == 0 ( answer = 0 )\\n2. n < 0 ( answer = INT_MAX , because it can\\'t go negative since\\nwe are picking up minimum we need to make this INT_MAX \\nso that it can not be part of our calculations )\\n```\\n\\n### Formula\\n```\\nfun(n) = perfect_square + fun(n - perfect_square)\\nso perfect_square can be from 1 to n\\n\\nSo basically we will iterate till perfect_square ( j*j <= n ), \\nwhere j*j is perfect_square\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n1 -> 1 + fun(0) -> 1\\n2 -> 1 + fun(1) -> 2 ( fun(1) already calculated )\\n3 -> 1 + fun(2) -> 3 ( fun(2) already calculated )\\n4 -> min(1 + fun(3), 4 + fun(0)) -> min(4, 1) -> 1\\n```\\n\\nSo in above example you can see for fun(4), when our perfect_square is 1, our answer is 4 and if we pick our next perfect_square then answer is 1, because 4 is itself a perfect square. So we will pick minimum among them and our final answer would be 1.\\n\\n## Let\\'s Code ( Bottom Up Approach )\\n```java []\\nclass Solution {\\n    public int numSquares(int n) {\\n        return solve(n);\\n    }\\n\\n    public int solve(int n) {\\n        if(n == 0) return 0;\\n        if(n < 0) return Integer.MAX_VALUE;\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1;i*i<=n;i++) {\\n            ans = Math.min(\\n                ans,\\n                1 + solve(n-(i*i))\\n            );\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nI\\'m excited to submit this,  are you ? Let\\'s submit.\\n![image.png](https:\/\/assets.leetcode.com\/users\/images\/faa67471-112d-4fea-9d43-29eb29c4c3fe_1707353513.0228646.png)\\n\\n\\nWhat the f**k ? It got TLE. Every programmer hate the `RED` color.\\n\\nNow let\\'s optimise it.\\n\\nSo in the approach section, I\\'ve mentioned for fun(2) we are using fun(1) and that we have already calculated, so no need to calculate it again. So\\nwhat I will do is I will store the answer for that intermediate state and will use if I need further.\\n\\nSo Let\\'s Optimise the code\\n\\n```java []\\nclass Solution {\\n\\n    int[] memo;\\n\\n    public int numSquares(int n) {\\n        memo = new int[n+1];\\n        Arrays.fill(memo, -1);\\n        return solve(n);\\n    }\\n\\n    public int solve(int n) {\\n        if(n == 0) return 0;\\n        if(n < 0) return Integer.MAX_VALUE;\\n        if(memo[n] != -1) return memo[n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=1;i*i<=n;i++) {\\n            ans = Math.min(\\n                ans,\\n                1 + solve(n-(i*i))\\n            );\\n        }\\n        return memo[n] = ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        memo = [-1] * (n + 1)\\n        \\n        def solve(n):\\n            if n == 0:\\n                return 0\\n            if n < 0:\\n                return float(\\'inf\\')\\n            if memo[n] != -1:\\n                return memo[n]\\n            ans = float(\\'inf\\')\\n            i = 1\\n            while i * i <= n:\\n                ans = min(ans, 1 + solve(n - i * i))\\n                i += 1\\n            memo[n] = ans\\n            return ans\\n        \\n        return solve(n)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    std::vector<int> memo;\\n\\n    int numSquares(int n) {\\n        memo.resize(n + 1, -1);\\n        return solve(n);\\n    }\\n\\n    int solve(int n) {\\n        if (n == 0) return 0;\\n        if (n < 0) return INT_MAX;\\n        if (memo[n] != -1) return memo[n];\\n        int ans = INT_MAX;\\n        for (int i = 1; i * i <= n; ++i) {\\n            ans = std::min(ans, 1 + solve(n - i * i));\\n        }\\n        return memo[n] = ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n^3\/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nNow every recursive problem can be converted into iterative solution, specially the problem that are overlapping ( means we are storing the intermediate state )\\n\\nSo let\\'s convert this into Iterative Approach\\n```Note []\\nIn Java code I have commented to understand better \\nhow we have converted into iterative solution.\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numSquares(int n) {\\n        int[] memo = new int[n+1];\\n        Arrays.fill(memo, Integer.MAX_VALUE); \/\/ because we are picking up minimum\\n        memo[0] = 0; \/\/ base condition\\n        \\n        for(int i=1;i<=n;i++) { \/\/ recursive function\\n            for(int j=1;j*j<=i;j++) { \/\/ loop in function\\n                memo[i] = Math.min(memo[i], 1 + memo[i-(j*j)]); \/\/ returning result\\n            }\\n        }\\n\\n        return memo[n];\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        memo = [float(\\'inf\\')] * (n + 1)\\n        memo[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            j = 1\\n            while j * j <= i:\\n                memo[i] = min(memo[i], 1 + memo[i - j * j])\\n                j += 1\\n                \\n        return memo[n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        std::vector<int> memo(n + 1, INT_MAX);\\n        memo[0] = 0;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 1; j*j <= i; ++j) {\\n                memo[i] = std::min(memo[i], 1 + memo[i - j*j]);\\n            }\\n        }\\n        \\n        return memo[n];\\n    }\\n};\\n```\\n\\nThat\\'s all guys !!!\\n\\nI would say if you understand this problem, there are many problems related to this.\\nYou can do all, I bet !\\n\\nThank you guys !!!\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\n"}
{"prompt":"<p>Given the <code>head<\/code> of a singly linked list, reverse the list, and return <em>the reversed list<\/em>.<\/p>\n\n<p>&nbsp;<\/p>\n<p><strong class=\"example\">Example 1:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/02\/19\/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2,3,4,5]\n<strong>Output:<\/strong> [5,4,3,2,1]\n<\/pre>\n\n<p><strong class=\"example\">Example 2:<\/strong><\/p>\n<img alt=\"\" src=\"https:\/\/assets.leetcode.com\/uploads\/2021\/02\/19\/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" \/>\n<pre>\n<strong>Input:<\/strong> head = [1,2]\n<strong>Output:<\/strong> [2,1]\n<\/pre>\n\n<p><strong class=\"example\">Example 3:<\/strong><\/p>\n\n<pre>\n<strong>Input:<\/strong> head = []\n<strong>Output:<\/strong> []\n<\/pre>\n\n<p>&nbsp;<\/p>\n<p><strong>Constraints:<\/strong><\/p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]<\/code>.<\/li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000<\/code><\/li>\n<\/ul>\n\n<p>&nbsp;<\/p>\n<p><strong>Follow up:<\/strong> A linked list can be reversed either iteratively or recursively. Could you implement both?<\/p>\n\n\n###\n\n","completion":" ```Interview []\\nIf you get this question in your interview and you haven\\'t solve this\\nit\\'s less possible to comeup with 3rd approach and to be honest questions\\non Binary Tree and Linked List are mostly asked that you have already\\nseen, I mean there is very less variety available until and unless\\ninterview himself made the questions but logic would be same.\\n```\\n\\nAnimation is at the end.\\n\\n\\n# Approach#1 ( Recursion )\\n<!-- Describe your approach to solving the problem. -->\\nMove to the next node till we reach the last node, now return this node to prev node, now change the returned node\\'s next to prev node. and now return prev node and do this recursively.\\nRemeber to change the curr node\\'s next to null, else you will end up in creating cycle.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(head);\\n        return newHead;\\n    }\\n\\n    public ListNode reverseListHelper(ListNode head) {\\n        if(head.next == null) return newHead = head;\\n        ListNode nextNode = reverseListHelper(head.next);\\n        nextNode.next = head;\\n        head.next = null;\\n        return head;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* newHead = nullptr;\\n\\n    ListNode* reverseList(ListNode* head) {\\n        if (head == nullptr) return nullptr;\\n        reverseListHelper(head);\\n        return newHead;\\n    }\\n\\n    ListNode* reverseListHelper(ListNode* head) {\\n        if (head->next == nullptr) {\\n            newHead = head;\\n            return head;\\n        }\\n        ListNode* nextNode = reverseListHelper(head->next);\\n        nextNode->next = head;\\n        head->next = nullptr;\\n        return head;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return None\\n        self.reverseListHelper(head)\\n        return self.newHead\\n    \\n    def reverseListHelper(self, head: ListNode) -> ListNode:\\n        if head.next is None:\\n            self.newHead = head\\n            return head\\n        nextNode = self.reverseListHelper(head.next)\\n        nextNode.next = head\\n        head.next = None\\n        return head\\n```\\n\\n# Approach#1 Optimisation\\nSince every time we will change the node\\'s next pointer to previous, so we don\\'t need to mark it as null except the first node, which has no previous node. So once we are done with recursion we will change first node\\'s next to null.\\n\\n# Code\\n```Java []\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(head);\\n        head.next = null;\\n        return newHead;\\n    }\\n\\n    public ListNode reverseListHelper(ListNode head) {\\n        if(head.next == null) return newHead = head;\\n        ListNode nextNode = reverseListHelper(head.next);\\n        nextNode.next = head;\\n        return head;\\n    }\\n}\\n```\\n\\n# Approach#2 ( Recursion , Early Poitner Change )\\nHere we will track prev and current node in our recursion stack and will change the current\\'s next to prev and then move to next node. now for next node, prev would be the current node.\\n\\n# Code\\n```\\n\/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n *\/\\nclass Solution {\\n    ListNode newHead;\\n    public ListNode reverseList(ListNode head) {\\n        if(head == null) return null;\\n        reverseListHelper(null, head);\\n        return newHead;\\n    }\\n\\n    public void reverseListHelper(ListNode prev, ListNode head) {\\n        if(head == null) return;\\n        if(head.next == null) {\\n            newHead = head;\\n        }\\n        ListNode next = head.next;\\n        head.next = prev;\\n        reverseListHelper(head, next);\\n    }\\n}\\n```\\n\\n# Approach#3 ( Two Pointer )\\nSee this video animation, you will understand it.\\nhttps:\/\/youtube.com\/shorts\/Du4elALktj8\\n\\nThe idea is always make sure, you store previous node and change current node\\'s next to previous node. and move to next node now since we are changing current node\\'s next so first we will store current node\\'s next node so that we don\\'t lose the node and that\\'s it.\\n\\nNow at the end your previous node would be the head of the linked list.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev = nullptr;\\n        ListNode *curr = head;\\n        while (curr != nullptr) {\\n            ListNode *nextTemp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n```Python3 []\\nclass Solution:\\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            next = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next\\n        return prev\\n```\\n```JavaScript []\\nvar reverseList = function(head) {\\n    let prev = null;\\n    let curr = head;\\n    while (curr !== null) {\\n        let nextTemp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = nextTemp;\\n    }\\n    return prev;\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun reverseList(head: ListNode?): ListNode? {\\n        var prev: ListNode? = null\\n        var curr = head\\n        while (curr != null) {\\n            val nextTemp = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = nextTemp\\n        }\\n        return prev\\n    }\\n}\\n```\\n\\nAnimation Video for Approach - 3 ( Open in new Tab for better experience )\\nor visit this link for slowed version\\nhttps:\/\/youtube.com\/shorts\/Du4elALktj8\\n![Reverse Linked List - Animation.gif](https:\/\/assets.leetcode.com\/users\/images\/fc58d7b7-caba-4f22-ab25-389274e331a3_1710993442.234485.gif)\\n\\nIf you like the blog, please upvote it.\\n\\n---\\n### Connect via\\n#### [1. Instagram](https:\/\/www.instagram.com\/cs_iitian\/) ( Follow )\\n#### [2. Facebook Page](https:\/\/www.facebook.com\/cs.iitian)\\n#### [3. Twitter](https:\/\/twitter.com\/cs_iitian)\\n#### [4. Blog](https:\/\/csiitian.blog\/) ( Subscribe to news letter )\\n#### [5. Medium](https:\/\/medium.com\/@csiitian)\\n#### [6. Youtube](https:\/\/www.youtube.com\/channel\/UCuxmikkhqbmBOUVxf-61hxw) ( Like, Share & Subscribe )\\n#### [7. Leetcode](https:\/\/leetcode.com\/cs_iitian\/)\\n\n"}
